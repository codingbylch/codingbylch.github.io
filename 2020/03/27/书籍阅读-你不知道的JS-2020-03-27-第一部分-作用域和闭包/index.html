<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人学习记录博客, 从这里开始吧"><title>第一部分 - 作用域和闭包 | 心平气和</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第一部分 - 作用域和闭包</h1><a id="logo" href="/.">心平气和</a><p class="description">^_^</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/demoShow/"><i class="fa fa-reddit-alien"> 演示</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第一部分 - 作用域和闭包</h1><div class="post-meta">Mar 27, 2020<span> | </span><span class="category"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2020/03/27/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB-%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS-2020-03-27-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/#vcomment"><span class="valine-comment-count" data-xid="/2020/03/27/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB-%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS-2020-03-27-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一章-作用域是什么"><span class="toc-number">1.</span> <span class="toc-text">第一章 - 作用域是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编译原理"><span class="toc-number">1.1.</span> <span class="toc-text">编译原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理解作用域"><span class="toc-number">1.2.</span> <span class="toc-text">理解作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域嵌套"><span class="toc-number">1.3.</span> <span class="toc-text">作用域嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常"><span class="toc-number">1.4.</span> <span class="toc-text">异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二章-词法作用域"><span class="toc-number">2.</span> <span class="toc-text">第二章 - 词法作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#欺骗词法（不要使用with和eval）"><span class="toc-number">2.1.</span> <span class="toc-text">欺骗词法（不要使用with和eval）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能"><span class="toc-number">2.2.</span> <span class="toc-text">性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第三章-函数作用域和块作用域"><span class="toc-number">3.</span> <span class="toc-text">第三章 - 函数作用域和块作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数中的作用域"><span class="toc-number">3.1.</span> <span class="toc-text">函数中的作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隐藏内部实现（一种规范叭）"><span class="toc-number">3.2.</span> <span class="toc-text">隐藏内部实现（一种规范叭）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数作用域与立即函数表达式"><span class="toc-number">3.3.</span> <span class="toc-text">函数作用域与立即函数表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名和具名"><span class="toc-number">3.4.</span> <span class="toc-text">匿名和具名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#块作用域"><span class="toc-number">3.5.</span> <span class="toc-text">块作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#with"><span class="toc-number">3.5.1.</span> <span class="toc-text">with</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try-catch"><span class="toc-number">3.5.2.</span> <span class="toc-text">try&#x2F;catch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#let"><span class="toc-number">3.5.3.</span> <span class="toc-text">let</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const"><span class="toc-number">3.5.4.</span> <span class="toc-text">const</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第四章-提升"><span class="toc-number">4.</span> <span class="toc-text">第四章 - 提升</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数优先"><span class="toc-number">4.1.</span> <span class="toc-text">函数优先</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第五章-作用域闭包"><span class="toc-number">5.</span> <span class="toc-text">第五章 - 作用域闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#循环和闭包"><span class="toc-number">5.1.</span> <span class="toc-text">循环和闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块"><span class="toc-number">5.2.</span> <span class="toc-text">模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#现代的模块机制"><span class="toc-number">5.2.1.</span> <span class="toc-text">现代的模块机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#未来的模块机制"><span class="toc-number">5.2.2.</span> <span class="toc-text">未来的模块机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附录A-动态作用域"><span class="toc-number">6.</span> <span class="toc-text">附录A - 动态作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附录B-块作用域的替代方案"><span class="toc-number">7.</span> <span class="toc-text">附录B - 块作用域的替代方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附录C-this词法"><span class="toc-number">8.</span> <span class="toc-text">附录C - this词法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#补充：预解析"><span class="toc-number">9.</span> <span class="toc-text">补充：预解析</span></a></li></ol></div></div><div class="post-content"><p>主要内容:</p>
<ul>
<li>作用域是什么</li>
<li>此法作用域</li>
<li>函数作用域和块作用域</li>
<li>提升</li>
<li>作用域闭包</li>
</ul>
<h2 id="第一章-作用域是什么"><a href="#第一章-作用域是什么" class="headerlink" title="第一章 - 作用域是什么"></a>第一章 - 作用域是什么</h2><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>JavaScript 引擎进行编译的步骤和传统的编译语言非常相似。简单地说，任何 JavaScript 代码片段<strong>在执行前都要进行编译</strong>（通常就在执行前）。在作用域的背后，用了<strong>很多优化</strong>来保证性能最佳。</p>
<h3 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h3><p>LHS查询：可以理解为赋值；<br>RHS查询：可以理解为取值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;  <span class="comment">//LHS</span></span><br><span class="line">    <span class="keyword">var</span> b = a;  <span class="comment">//LHS,RHS</span></span><br><span class="line">    <span class="keyword">return</span> a + b; <span class="comment">// RHS,RHS</span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> c = foo( <span class="number">2</span> ); <span class="comment">//LHS, RHS(focus foo(...))</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h3><p><strong>什么是作用域嵌套</strong>：一个块或函数在另外一个作用域中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我是全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 我是函数里面的作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在当前作用域内找不到变量的声明，那就会到外面的作用域去找。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>ReferenceError：找不到变量的声明；<br>TypeError：找到了变量但操作不当。</p>
<h2 id="第二章-词法作用域"><a href="#第二章-词法作用域" class="headerlink" title="第二章 - 词法作用域"></a>第二章 - 词法作用域</h2><p>作用域层层嵌套，通常会<strong>从内到外</strong>进行变量的查找，作用于的查找在找到第一个匹配的变量就会停止（<strong>遮蔽效应</strong>）。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200327014629.png" alt="作用域“气泡”"></p>
<h3 id="欺骗词法（不要使用with和eval）"><a href="#欺骗词法（不要使用with和eval）" class="headerlink" title="欺骗词法（不要使用with和eval）"></a>欺骗词法（不要使用with和eval）</h3><p>JS有两种机制来实现欺骗词法作用域的目的，但都会导致性能的下降。<br><strong>什么是eval</strong>：eval(…)函数可以接受一个字符串为参数，将其当成就在此处写的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">eval</span>( str ); <span class="comment">// 欺骗！ </span></span><br><span class="line">    <span class="built_in">console</span>.log( a, b ); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>; </span><br><span class="line"> </span><br><span class="line">foo( <span class="string">"var b = 3;"</span>, <span class="number">1</span> ); <span class="comment">// 1, 3</span></span><br></pre></td></tr></table></figure>
<p><strong>何时用eval</strong>：eval(..) 通常被用来执行动态创建的代码。无论何种情况，eval(..) 都可以在运行期修改书写期的词法作用域。严格模式中，eval(..) 在运行时有其自己的词法作用域：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str</span>) </span>&#123; </span><br><span class="line"><span class="meta">    "use strict"</span>; </span><br><span class="line">    <span class="built_in">eval</span>( str ); </span><br><span class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// ReferenceError: a is not defined </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">foo( <span class="string">"var a = 2"</span> );</span><br></pre></td></tr></table></figure>
<p>不建议在setTimeout(…)、setInterval(…)和new Function(..)的第一个参数用字符串。</p>
<p><strong>什么是with</strong>：with也是一个用于欺骗词法作用域的关键字。<strong>with 通常被当作重复引用同一个对象中的多个属性的快捷方式</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    a: <span class="number">1</span>, </span><br><span class="line">    b: <span class="number">2</span>, </span><br><span class="line">    c: <span class="number">3</span> </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 单调乏味的重复 "obj" </span></span><br><span class="line">obj.a = <span class="number">2</span>; </span><br><span class="line">obj.b = <span class="number">3</span>; </span><br><span class="line">obj.c = <span class="number">4</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 简单的快捷方式 </span></span><br><span class="line"><span class="keyword">with</span> (obj) &#123; </span><br><span class="line">    a = <span class="number">3</span>; </span><br><span class="line">    b = <span class="number">4</span>; </span><br><span class="line">    c = <span class="number">5</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但可能会出现以下情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">with</span> (obj) &#123; </span><br><span class="line">        a = <span class="number">2</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> o1 = &#123; </span><br><span class="line">    a: <span class="number">3</span> </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> o2 = &#123; </span><br><span class="line">    b: <span class="number">3</span> </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">foo( o1 ); </span><br><span class="line"><span class="built_in">console</span>.log( o1.a ); <span class="comment">// 2 </span></span><br><span class="line"> </span><br><span class="line">foo( o2 ); </span><br><span class="line"><span class="built_in">console</span>.log( o2.a ); <span class="comment">// undefined </span></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2——不好，a 被泄漏到全局作用域上了！</span></span><br></pre></td></tr></table></figure>
<p>可以注意到一个奇怪的副作用，实际上 a = 2 赋值操作创建了一个全局的变量 a。why?????<br><strong>解释</strong>：with 声明实际上会根据你传递给它的对象凭空创建一个全新的词法作用域。那么当o2传进去，则有一个o2专属的作用域。但o2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此执行a=2时，就会自动创建一个全局变量（非严格）。</p>
<blockquote>
<p>不推荐使用eval和with，且严格模式下with被完全禁止，eval也受限。</p>
</blockquote>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>欺骗词法通过在运行时修改或创建新的作用域，以此来欺骗其它已被定义的作用域。<br><strong>有什么影响</strong>：这会影响JS在编译阶段对代码的性能优化：当代码中出现的eval或with，关于标识符位置的判断优化就会无效。最坏的情况就是所有优化可能都无效，因为eval和with之后所带进来的代码不确定，对作用域的修改也不确定，那只能放弃性能优化。</p>
<h2 id="第三章-函数作用域和块作用域"><a href="#第三章-函数作用域和块作用域" class="headerlink" title="第三章 - 函数作用域和块作用域"></a>第三章 - 函数作用域和块作用域</h2><p><strong>疑问</strong>：是什么生成作用域气泡？只有函数才会生成新的气泡吗？JS中的其它结构能否生成新气泡？</p>
<h3 id="函数中的作用域"><a href="#函数中的作用域" class="headerlink" title="函数中的作用域"></a>函数中的作用域</h3><p>每声明一个函数就会创建一个新气泡。<br><strong>函数作用域的含义</strong>：属于函数作用域内的变量都可以在整个函数作用域内使用（嵌套在里面的作用域也可以使用（因为由内往外））。</p>
<h3 id="隐藏内部实现（一种规范叭）"><a href="#隐藏内部实现（一种规范叭）" class="headerlink" title="隐藏内部实现（一种规范叭）"></a>隐藏内部实现（一种规范叭）</h3><p>使用函数声明把变量和函数都包裹起来，那这种“隐藏”有什么作用？<br>解释：</p>
<ol>
<li>最小授权或最小暴露原则，避免被外部以非预期的方式使用。</li>
<li>可以规避同名标识符之间的冲突。</li>
</ol>
<p>如何规避冲突：1.本地变量声明；2.采用完全不同的变量名称（标识符名称）</p>
<p>使用情景：1.全局命名空间（如对象不想将标识符暴露在全局作用域中）；2.模块管理</p>
<h3 id="函数作用域与立即函数表达式"><a href="#函数作用域与立即函数表达式" class="headerlink" title="函数作用域与立即函数表达式"></a>函数作用域与立即函数表达式</h3><p>将任意代码用函数声明包装起来，则外部作用域无法访问里面的内容。<br><strong>疑问</strong>：解决了一部分问题也带来了新的问题，就是所声明的函数名称会”污染“所在的作用域。<br><strong>如何解决</strong>：立即函数表达式。</p>
<p><strong>立即函数表达式IIFE（Immediately Invoked Function Expression）</strong>：<br>立即函数表达式的通用写法：(function fn(){…})();<br>这里的fn被绑定在函数表达式自身的函数中而不是所在作用域中，从而实现”无污染“，也就是说，所在作用域是没有机会访问该函数的。</p>
<ul>
<li><p>IIFE用法一：匿名函数表达式：(function(){…})()</p>
</li>
<li><p>IIFE用法二：传递参数并当作函数调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">global</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 3 </span></span><br><span class="line">    <span class="built_in">console</span>.log(global.a); <span class="comment">// 2 </span></span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// </span></span><br><span class="line"><span class="comment">// 这对改进代码风格有帮助</span></span><br></pre></td></tr></table></figure>
<p>这个模式的另外一个应用场景是解决 undefined 标识符的默认值被错误覆盖导致的异常（很不常见，除非恶意挖坑..）</p>
</li>
<li><p>IIFE用法三：倒置代码的运行顺序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">def</span>) </span>&#123;</span><br><span class="line">    def(<span class="built_in">window</span>);</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params">global</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 3 </span></span><br><span class="line">    <span class="built_in">console</span>.log(global.a); <span class="comment">// 2 </span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种模式在UMD（Universal Module Definition）项目中被广泛使用。</p>
</li>
</ul>
<h3 id="匿名和具名"><a href="#匿名和具名" class="headerlink" title="匿名和具名"></a>匿名和具名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// Uncaught SyntaxError: Unexpected token (，无效的语法错误的函数声明</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)() <span class="comment">//ok, 这是函数表达式</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>上面反映了函数表达式可以匿名，但函数声明不可以忽略函数名，这在JS是非法的。<br><strong>匿名函数的缺点</strong>：</p>
<ul>
<li>在栈追踪中不会显示有意义的函数名，调试困难。</li>
<li>在递归中当函数引用自身时只能使用arguments.callee（为何已过期）；另外在事件触发后则无法解绑事件监听器。</li>
<li>可读性下降。</li>
</ul>
<h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>除了函数作用域以外，还有其它类型的作用域：块作用域。<br>var所声明的变量在for、if中与所在作用域的其它地方声明是一样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 1~9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>开发者原意只想让i在for的块作用域内生效，但这里的i”污染“了整个作用域。怎么解决整个问题呢？表面上看 JavaScript 并没有块作用域的相关功能。</p>
<h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>with是块作用域的一种形式：使用with从对象中创建的作用域仅在with声明的作用域中有效。</p>
<h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h4><p>ES3中try/catch的catch分局会创建一个块作用域，声明的变量只在该作用域内有效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="literal">undefined</span>(); <span class="comment">// 执行一个非法操作来强制制造一个异常 </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 能够正常执行！ </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(err); <span class="comment">// ReferenceError: err not found</span></span><br></pre></td></tr></table></figure>

<h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>ES6引入let：可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。let无法变量提升。<br>隐式与显式：在已存在的{…}内使用let声明变量，是隐式的，如果不小心移动到其它块中，可能就会导致错误。可以为let创建显式的块作用域（即使用{..}将包含let的一部分代码括号起来）</p>
<ul>
<li><p>垃圾收集<br>块作用域还和闭包、垃圾回收机制有关。使用块作用域，可以让引擎清楚地知道没有必要继续保存 someReallyBigData了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在这里做点有趣的事情 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这个块中定义的内容可以销毁了！ </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> someReallyBigData = &#123;</span><br><span class="line">        ..</span><br><span class="line">    &#125;;</span><br><span class="line">    process(someReallyBigData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"my_button"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"button clicked"</span>);</span><br><span class="line">&#125;, <span class="comment">/*capturingPhase=*/</span> <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>let循环<br>每个迭代进行重新绑定，确保能够重新赋值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>也可创建块作用域，值是固定常量。</p>
<h2 id="第四章-提升"><a href="#第四章-提升" class="headerlink" title="第四章 - 提升"></a>第四章 - 提升</h2><p>问题：先有声明还是先有赋值？<br>结论：先有声明后有赋值。</p>
<ul>
<li><p>变量声明提升：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>对上面代码的解释：JS会在解释代码之前先编译，编译的工作之一就是找出所有声明，并用合适的作用域关联起来。var a = 2将被看成两个声明：var a和a = 2。编译阶段进行定义声明，第二个赋值声明则等待执行。<br>于是第一段代码可以看作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a; </span><br><span class="line">a = <span class="number">2</span>; </span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数声明也会被提升，但是函数表达式却不会被提升：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 不是 ReferenceError, 而是 TypeError! </span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h3><p>函数在变量之前先被提升。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 1 </span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>避免重复声明。</p>
<h2 id="第五章-作用域闭包"><a href="#第五章-作用域闭包" class="headerlink" title="第五章 - 作用域闭包"></a>第五章 - 作用域闭包</h2><p><strong>闭包定义</strong>：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使<strong>函数是在当前词法作用域之外执行</strong>。<br>词法作用域的查找规则也是闭包的一部分：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a); <span class="comment">// 2 </span></span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>但这无法清晰地展示闭包，确切地说<strong>这不是闭包</strong>。<br>下段代码可以清晰地展示闭包：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="built_in">console</span>.log( a ); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> bar; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> baz = foo(); </span><br><span class="line">baz(); <span class="comment">// 2 —— 朋友，这就是闭包的效果。</span></span><br></pre></td></tr></table></figure>
<p>原本foo()执行完之后，其内部作用域也应随之而被销毁。但内部函数bar()被引用，阻止了回收。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。<br>这也是闭包：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x) <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    c(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    fn(); <span class="comment">// 妈妈快看呀，这就是闭包！</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure>
<p>无论什么手段将内部函数传递到所外词法作用域之外，都会持有对原始定义作用域的引用，无论何时执行这个函数都会使用闭包。<br>（表面上看：外部可以访问一个函数内部作用域里的函数，而这个内部函数又有对所在作用域变量的引用，那就使用了闭包）</p>
<p>来看setTimeout的<strong>例子</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(message)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait(<span class="string">'hello world.'</span>)</span><br></pre></td></tr></table></figure>
<p>这里的timer就是wait()函数的内部函数，且持有对messge的引用，内部工具函数setTimeout(…)引用了timer()这个函数。这就是闭包。<br>在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！<br>IIFE严格上来说不算闭包。</p>
<h3 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h3><p>来看一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="comment">// 6,6,6,6,6</span></span><br></pre></td></tr></table></figure>
<p>由于setTimeout使得回调函数是在循环结束之后才调用的，这导致这些回调函数都在调用同一个i的引用，但实际上我们想要回调函数各自捕获一个i的副本。<br>如何解决：使用IIFE并在每次迭代储存i的值，可以这么写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j);</span><br><span class="line">        &#125;, j * <span class="number">1000</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>什么是模块：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 外部封闭函数</span></span><br><span class="line">    <span class="keyword">var</span> something = <span class="string">"cool"</span>;</span><br><span class="line">    <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 内部函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(something);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(another.join(<span class="string">" ! "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 返回必须至少有一个内部函数</span></span><br><span class="line">        doSomething: doSomething, </span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = CoolModule();</span><br><span class="line">foo.doSomething(); <span class="comment">// cool </span></span><br><span class="line">foo.doAnother(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>
<p>这种模式被称为模块。模块模式必须具备两个条件：1.必须具有外部封闭函数且至少被调用一次；2.封闭函数至少返回一个内部函数，这样才能形成闭包。</p>
<h4 id="现代的模块机制"><a href="#现代的模块机制" class="headerlink" title="现代的模块机制"></a>现代的模块机制</h4><p>大多数模块依赖加载器 / 管理器本质上都是将这种模块定义封装进一个友好的 API。这里介绍一下核心概念：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyModules = (<span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> modules = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name, deps, impl</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; deps.length; i++) &#123;</span><br><span class="line">            deps[i] = modules[deps[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        modules[name] = impl.apply(impl, deps); <span class="comment">//如果不理解apply，复习一下</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modules[name];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        define: define,</span><br><span class="line">        <span class="keyword">get</span>: <span class="keyword">get</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="未来的模块机制"><a href="#未来的模块机制" class="headerlink" title="未来的模块机制"></a>未来的模块机制</h4><p>先略过。</p>
<h2 id="附录A-动态作用域"><a href="#附录A-动态作用域" class="headerlink" title="附录A - 动态作用域"></a>附录A - 动态作用域</h2><p>词法作用域：JS的作用域是词法作用域，词法作用域最重要的特征是它的定义过程发生在代码的书写阶段（假设你没有使用eval() 或 with）。</p>
<p>动态作用域：并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。</p>
<p>this的机制很像动态作用域。</p>
<h2 id="附录B-块作用域的替代方案"><a href="#附录B-块作用域的替代方案" class="headerlink" title="附录B - 块作用域的替代方案"></a>附录B - 块作用域的替代方案</h2><p>有些浏览器还不支持ES6，为了兼容性则需要有块作用域的替代方案。实际上，使用代码转换工具来对 ES6 代码进行处理，生成兼容 ES5的代码即可。如google的 Traceur 的项目。</p>
<h2 id="附录C-this词法"><a href="#附录C-this词法" class="headerlink" title="附录C - this词法"></a>附录C - this词法</h2><p>this、匿名函数、bind()</p>
<h2 id="补充：预解析"><a href="#补充：预解析" class="headerlink" title="补充：预解析"></a>补充：预解析</h2><p>在ES6之前，使用var声明会存在变量的预解析，函数也有预解析。这里介绍一下预解析的机制。</p>
<p>什么是预解析：在当前作用域中，在JS代码执行前，浏览器会把搜索var和function声明的变量提前进行声明或定义。</p>
<ul>
<li><p>声明和定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">24</span></span><br></pre></td></tr></table></figure>
<p>先声明: var num, 然后再定义: num = 12。</p>
</li>
<li><p>var声明和function声明在预解析的区别<br>var声明的变量在预解析的时候只是提前的声明，function声明的函数在预解析的时候会提前声明并且会同时定义。</p>
</li>
<li><p>全局作用域下带var和不带var的区别<br>  区别一：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(num1); <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num2); <span class="comment">// ReferenceError: num2 is not defined</span></span><br><span class="line">num2 = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<p>  区别二：<br>  num2 = 12; 相当于给window增加了一个num2的属性名，属性值是12；<br>  var num1 = 12; 相当于给全局作用域增加了一个全局变量num1，但是不仅如此，它也相当于给window增加了一个属性名num，属性值是12</p>
</li>
<li><p>预解析中的一些变态机制</p>
<ul>
<li>不管条件是否成立，都要把带var的进行提前的声明</li>
<li>只预解析“=”左边的，右边的是指针，不参与预解析<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn(); <span class="comment">// -&gt; undefined();  // Uncaught TypeError: fn is not a function</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); -&gt; <span class="string">'ok'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn(); -&gt; <span class="string">'ok'</span></span><br></pre></td></tr></table></figure></li>
<li>return下的代码依然会进行预解析</li>
<li>名字已经声明过了，不需要重新的声明，但是需要重新的赋值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// Uncaught TypeError: fn is not a function</span></span><br></pre></td></tr></table></figure>
一道经典题目：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn(); <span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// -&gt; 2                                </span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">10</span>; <span class="comment">//  fn = 10 </span></span><br><span class="line">fn(); <span class="comment">// -&gt; 10()  Uncaught TypeError: fn is not a function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">//不执行</span></span><br></pre></td></tr></table></figure>
其实就相当于：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// 2</span></span><br><span class="line">fn(); <span class="comment">// 2</span></span><br><span class="line">fn = <span class="number">10</span>;</span><br><span class="line">fn();</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</div><div class="tags"><a href="/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS/">你不知道的JS</a></div><div class="post-nav"><a class="pre" href="/2020/03/27/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB-%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS-2020-03-27-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/">第二部分 - this和对象原型</a><a class="next" href="/2020/03/26/JS%E7%9B%B8%E5%85%B3-2020-03-26-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/">深入理解ES6</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' ? true : false;
var verify = 'false' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'Fr37gA6FmBqLSAcaSAxrdyOw-gzGzoHsz',
  appKey:'YWEJwHPUixRYKn7WgjJxrKHn',
  placeholder:'Just so so',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/04/%E5%85%B6%E5%AE%83-2020-05-04-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/">操作系统相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/17/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3-2020-04-17-TCP%E6%8F%A1%E6%89%8B%E3%80%81%E6%8C%A5%E6%89%8B%E6%80%BB%E7%BB%93/">TCP握手、挥手总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/16/JS%E7%9B%B8%E5%85%B3-2020-04-16-%E7%AC%AC%E5%8D%81%E7%AB%A0-DOM%E5%9F%BA%E7%A1%80/">第十章-DOM基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/10/%E6%A1%86%E6%9E%B6-webpack-2020-04-10-Webpack%E5%85%A5%E9%97%A8/">Webpack入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/08/CSS%E7%9B%B8%E5%85%B3-2020-04-08-CSS%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3/">CSS布局相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/03/JS%E7%9B%B8%E5%85%B3-2020-04-03-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6-%E7%B1%BB/">Class的基本语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/02/JS%E7%9B%B8%E5%85%B3-2020-04-02-Promise%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">Promise与异步编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/02/JS%E7%9B%B8%E5%85%B3-2020-04-02-%E5%B8%B8%E8%A7%81%E7%9A%84DOM%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F/">常见的DOM操作方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/01/JS%E7%9B%B8%E5%85%B3-2020-04-01-Ajax%E4%B8%8EComet/">Ajax的一些基本操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/CSS%E7%9B%B8%E5%85%B3-2020-03-31-CSS-%E8%83%8C%E6%99%AF%E4%B8%8E%E8%BE%B9%E6%A1%86/">CSS - 背景与边框</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://chochi1st.github.io" title="Chochi" target="_blank">Chochi</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">心平气和.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>