<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>操作系统相关</title>
    <url>/2020/05/04/%E5%85%B6%E5%AE%83-2020-05-04-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>简介：进程方面的一些基本概念复习，来自王道《操作系统》</p>
<a id="more"></a>
<h2 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>并发：<strong>一段时间间隔</strong>多道程序运行<br>并行：<strong>某一时刻</strong>多个程序运行</p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>共享：指的是系统中资源可供内存中多个并发执行的进程共同使用。<br>有两种资源共享的方式：</p>
<ol>
<li>互斥共享方式：规定<strong>一段时间内只能一个进程访问资源</strong>，其它进程需要等待。这个资源被称作<strong>临界资源</strong>。大多数物理设备、软件中使用的栈、变量等都属于临界资源。</li>
<li>同时访问方式：允许资源在一段时间内被多个进程“同时”访问，这里的“同时”通常是宏观上的。</li>
</ol>
<h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p><strong>虚拟</strong>：指的是把一个物理上的实体变为若干个逻辑上的对应物。<br>用于实现虚拟的技术，称作<strong>虚拟技术</strong>。操作系统利用多种虚拟技术实现了虚拟处理器、虚拟内存、虚拟外部设备等。<br><strong>虚拟处理器技术</strong>：利用多道程序设计技术，让多个程序可以分时使用一个处理器。即把一个物理上的CPU虚拟化成了多个逻辑上的CPU（虚拟处理器）。<br><strong>虚拟存储器技术</strong>：把一个物理存储器变为虚拟存储器，在逻辑上扩充存储器的容量。我们把用户感觉到的存储器称作虚拟存储器。<br><strong>虚拟I/O</strong>：把一台物理I/O虚拟化为多个逻辑上的I/O设备。<br>操作系统的虚拟技术可归纳为：<strong>时分复用技术</strong>：如处理器的分时共享；<strong>空分复用技术</strong>：如虚拟存储器。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><strong>进程实体</strong>：由程序段、相关数据段、PCB三部分组成。<br><strong>进程的定义</strong>：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。<br><strong>进程的五种状态</strong>：创建态、就绪态、运行态、阻塞态、结束态。</p>
<ul>
<li>运行态：单处理机下，每个时刻最多一个进程处于运行态；</li>
<li>就绪态：进程获得了除处理器资源外的一切资源，一旦获得处理器资源就能进入运行态；</li>
<li>阻塞态：进程因为等待某一事件而暂停运行。如等待某资源可用/等待输入输出。即使处理器空间也不会运行。</li>
<li>创建态：进程正在被创建，还未到就绪态；</li>
<li>结束态：进程可能正常结束或者其他原因中断退出。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200504181058.png" alt="5种状态转换"></p>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>高级通信方法主要有三种：</p>
<ul>
<li><p>共享存储<br>在通信的进程之间存在一块可直接访问的共享空间。通过对这个共享空间的读/写操作来实现进程间的通信。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200504181543.png" alt="共享存储"></p>
</li>
<li><p>消息传递<br>进程间的数据交换是以格式化的信息（Message）为单位的。若进程之间不存在共享空间，必须利用操作系统提供的消息传递方法来实现进程通信。即进程间通过发送消息、接收消息的原语来进行数据交换。<br>有两种消息传递的方式：</p>
<ul>
<li>直接通信方式：发送进程把消息发送给接收进程，并将其挂载到接收进程的消息缓冲队列中，接受进程通过消息缓冲队列取得消息。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200504182627.png" alt=""></li>
<li>间接通信方式：发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息。这种中间实体一般称作信箱。</li>
</ul>
</li>
<li><p>管道通信<br>所谓的管道，指的是连接一个读进程和写进程的一个共享文件（又称pipe文件），以实现两者之间的通信。<strong>半双工通信</strong>。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200504182950.png" alt=""><br>管道通信可以看作是共享存储的优化和发展。在共享存储中，同一时刻只允许一种操作，管道是半双工通信，要求只能一边写入，一边读出，只要管道中有数据就能进行读取，不会因为其它进程进行写操作而堵塞读操作，因为管道要求写进程需要把缓冲区写满，才能让读进程读取。</p>
</li>
</ul>
<h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p>是基本的CPU执行单元，也是程序执行流的最小单元。线程是进程中的一个实体，<strong>是系统独立调度和分派的基本单位</strong>。线程本身不拥有系统资源，而是与进程中其它线程共享进程所拥有的资源。<br>线程也有就绪、阻塞、运行三种基本状态。<br>而<strong>进程是拥有资源的基本单位</strong>。<br><strong>引入线程的目的</strong>：为了减小程序在并发执行所付出的时空开销。<br>可以认为线程是“轻量级的进程”</p>
<h3 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h3><p>为什么需要有调度：因为进程数量通常远大于处理器的个数，这时候就会发生进程间争用处理器资源的现象。我们需要一种算法来实现对处理器资源的合理分配。</p>
<h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3><ol>
<li>非剥夺调度方式</li>
<li>剥夺调度方式</li>
</ol>
<h3 id="典型的调度算法"><a href="#典型的调度算法" class="headerlink" title="典型的调度算法"></a>典型的调度算法</h3><ol>
<li><strong>先来先服务调度算法</strong>：每次从就绪队列中选择最先进入该队列的进程，将处理器分配给它。属于不可剥夺算法。特点：算法简单，但效率低；对长作业有利，对短作业不利；有利于CPU繁忙型作业，不利于I/O繁忙型作业。</li>
<li><strong>短作业优先调度算法</strong>：从后备队列中选择一个运行时间最短的作业。对长时间作业不利，可能会造成“饥饿”现象（区别于死锁）</li>
<li><strong>优先级调度算法</strong>：每次从后背队列中选取优先级最高的作业。<ul>
<li>非剥夺式优先级调度算法</li>
<li>剥夺式优先级调度算法</li>
<li>静态优先级调度算法</li>
<li>动态优先级调度算法</li>
</ul>
</li>
<li><strong>高响应比优先调度算法</strong>：选取响应比最高的作业。先来先服务+短作业：克服了饥饿状态兼顾了长作业。</li>
<li><strong>时间片轮转调度算法</strong>：主要适用于分时系统。对于时间片的大小应该适当设置。</li>
<li><strong>多级反馈队列调度算法</strong>：以上的综合</li>
</ol>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁的定义</strong>：多个进程因为竞争资源而陷入了相互等待的情况。若没有外力作用，这些进程无法向前推进。<br><strong>为什么会产生死锁</strong>：</p>
<ul>
<li>系统资源的竞争：系统中有不可剥夺的资源，通常不够满足所有进程的需要，使得进程在争夺资源的过程中陷入了相互等待。</li>
<li>进程推进顺序非法：如信号量使用不当造成两个进程相互等待对方发送消息。</li>
</ul>
<p><strong>产生死锁的必要条件</strong>：<br>四个条件只要任一不成立，死锁就不会发生。</p>
<ol>
<li>互斥条件：某段事件进程独占资源</li>
<li>不剥夺条件：资源在被使用时无法被强行剥夺</li>
<li>请求并保持条件：进程保持着资源同时请求另一资源，对保持的资源不释放</li>
<li>循环等待条件：进程间循环等待资源</li>
</ol>
<p><strong>死锁的处理策略</strong>：</p>
<ul>
<li>死锁预防：破环四个必要条件之一。</li>
<li>死锁避免：在资源动态分配的过程中，使用某种方法防止系统进入不安全的状态来避免死锁。<ul>
<li>银行家算法</li>
</ul>
</li>
<li>死锁检测与解除：<ul>
<li>死锁检测：系统死锁可以利用资源分配图来进行查看。<strong>通过简化资源分配图可以检测是否为死锁状态</strong>。死锁的状态图是完全不能简化的，这称作死锁定理。</li>
<li>死锁解除：1）资源剥夺法；2）撤销进程法；3）进程回退法</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP握手、挥手总结</title>
    <url>/2020/04/17/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3-2020-04-17-TCP%E6%8F%A1%E6%89%8B%E3%80%81%E6%8C%A5%E6%89%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>简介：关于TCP的三次握手、四次挥手比较正确的解释。</p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/TCP%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%92%8C%E6%8F%A1%E6%89%8B.jpg" alt=""><br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200417122659.png" alt=""><br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200417122710.png" alt=""><br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200417122806.png" alt="TCP通信流程"></p>
<blockquote>
<p>参考资料：<a href="https://blog.csdn.net/lengxiao1993/article/details/82771768" target="_blank" rel="noopener">TCP 为什么三次握手而不是两次握手（正解版）</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>第十章-DOM基础</title>
    <url>/2020/04/16/JS%E7%9B%B8%E5%85%B3-2020-04-16-%E7%AC%AC%E5%8D%81%E7%AB%A0-DOM%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>简介：介绍了DOM的相关节点和操作，对应JS红宝书第10-11章。</p>
<a id="more"></a>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>HTML和XML里有很多节点。<br>最外层的称作文档节点（文档元素），也是每个文档的根节点。在HTML中就是html这个元素。<br>一共有12中元素节点类型，这里例举我觉得常用的。分别是Node、Document、Element、Text。平常最常用的应该就是Element吧。</p>
<h3 id="Node类型："><a href="#Node类型：" class="headerlink" title="Node类型："></a>Node类型：</h3><p>最基本的节点类型是 Node，用于抽象地表示文档中一个独立的部分；所有其他类型都继承自Node。 每个节点都有一个 nodeType 属性，用于表明节点的类型。如someNode.nodeType == 1表示someNode为element元素节点。</p>
<ol>
<li>nodeName 和 nodeValue 属性 </li>
<li>节点关系：<ol>
<li>每个节点都有一个 childNodes 属性，其中保存着一个 NodeList 对象。NodeList 是一种类数组对象，用于保存一组有序的节点，访问方式：someNode.childNodes[0]。</li>
<li>每个节点都有一个 parentNode 属性，该属性指向文档树中的父节点。</li>
<li>每个节点的 previousSibling和 nextSibling 属性，可以访问同一列表中的其他节点。</li>
<li>父节点的firstChild和lastChild分别指向其childNodes中的第一个和最后一个节点。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200416210209.png" alt="节点间的关系"></li>
<li>hasChildNodes()检查是否有子节点</li>
<li>所有节点都有的最后一个属性是 ownerDocument，该属性指向表示整个文档的文档节点。</li>
</ol>
</li>
<li>操作节点<ol>
<li>appendChild()：用于childNodes列表末尾添加一个节点，函数返回添加的节点。</li>
<li>insertBefore(要插入的节点，作为参照的节点)：将节点插到特定位置，会在参照节点的前面；若参照节点为Null，则等于appendChild()。返回被插入节点</li>
<li>replaceChild(插入节点，替换节点)，返回被替换的节点</li>
<li>removeChild(想移除的节点)移除某个节点，返回移除节点</li>
</ol>
</li>
<li>其它方法：<ol>
<li>cloneNode(是否深复制true false)：克隆节点。深复制会复制相关文档树，比如复制有子节点的ul元素，子节点都会包括，而浅复制只是单单复制ul这个节点。</li>
<li>normalize()：处理文档中的文本节点</li>
</ol>
</li>
</ol>
<h3 id="Document类型："><a href="#Document类型：" class="headerlink" title="Document类型："></a>Document类型：</h3><p>nodeType 的值为 9，nodeName 的值为”#document”；</p>
<ol>
<li>文档的子节点：documentElement、firstChild 和 childNodes[0]的值相同，都指向html元素。</li>
<li>文档信息：document.title取得文档标题；document.URL取得完整的 URL ；document.domain取得域名（domain可修改，可用来解决框架间的跨域限制） ；document.referrer取得来源页面的 URL 。</li>
<li>查找元素：<ol>
<li>getElementById()：接收一个参数：要取得的元素的 ID。只返回文档中第一次出现的元素</li>
<li>getElementsByTagName()：接受一个参数，即要取得元素的标签名，而返回的是包含零或多个元素的 NodeList。在 HTML 文档中，这个方法会返回一个 HTMLCollection 对象。要想取得文档中的所有元素，使用“*”。</li>
<li>getElementsByName()：返回带有给定 name 特性的所有元素。</li>
</ol>
</li>
</ol>
<h3 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h3><p>nodeType 的值为 1；<br>访问元素标签名：nodeName, tagName<br>nodeName 的值为元素的标签名；要访问元素的标签名，可以使用nodeName属性，也可以使用tagName属性；在 HTML 中，标签名始终都以全部大写表示；</p>
<ol>
<li>HTML 元素：所有 HTML 元素都由 HTMLElement 类型表示，HTMLElement类型直接继承自 Element并添加了一些属性。<ol>
<li>id:元素在文档中的唯一标识符</li>
<li>title:附加信息说明</li>
<li>className：class名</li>
</ol>
</li>
<li>取得特性：每个元素都有一或多个特性，DOM 方法主要有三个：<ol>
<li>getAttribute(“属性名”)获取属性值，不常用，更多用.属性名，除非访问自定义。</li>
<li>setAttribute()设置属性值，更多用于设置自定义的属性值。平常访问用”.”操作符来进行赋值。</li>
<li>removeAttribute()：删除元素特性（属性），不常用。</li>
</ol>
</li>
<li>attributes 属性 </li>
<li>创建元素： document.createElement()</li>
</ol>
<p>从本质上说，所有 NodeList 对象都是在访问 DOM 文档时<strong>实时运行的查询</strong>。下列代码会导致无限循环：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>),</span><br><span class="line">    i,</span><br><span class="line">    div;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; divs.length; i++) &#123;</span><br><span class="line">    div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，应该尽量减少访问 NodeList 的次数。因为每次访问 NodeList，都会运行一次基于文档的查询。应考虑将其值缓存起来。</p>
<h2 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a>DOM扩展</h2><h3 id="选择符-API"><a href="#选择符-API" class="headerlink" title="选择符 API"></a>选择符 API</h3><p>之前对元素的选择需要通过getDocumentById等方法，能不能使用接收css选择符的方法来选择一个元素呢？于是querySelector(‘css选择符’)应运而生。<br>Selectors API Level 1 的核心是两个方法：querySelector()和 querySelectorAll()。</p>
<ul>
<li>querySelector()  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取得 body 元素 </span></span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">"body"</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//取得 ID 为"myDiv"的元素 </span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.querySelector(<span class="string">"#myDiv"</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//取得类为"selected"的第一个元素 </span></span><br><span class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.querySelector(<span class="string">".selected"</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//取得类为"button"的第一个图像元素 </span></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.body.querySelector(<span class="string">"img.button"</span>);</span><br></pre></td></tr></table></figure></li>
<li>querySelectorAll()<br>返回的是所有匹配的元素而不仅仅是一个元素。这个方法返回的是一个 NodeList 的实例。其底层实现则类似于一组元素的快照，而非不断对文档进行搜索的动态查询。 可避免性能问题。</li>
<li>matchesSelector()方法：接收一个参数，即 CSS 选择符，如果调用元素与该选择符匹配，返回 true；使用这个方法能够方便地检测它是否会被 querySelector()或querySelectorAll()方法返回。 </li>
</ul>
<h3 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h3><p>由于使用节点可能存在文本节点，遍历可能会被返回，为了避免此情况，Element Traversal API 为 DOM 元素添加了以下 5 个属性。 </p>
<ul>
<li>childElementCount：返回子元素（不包括文本节点和注释）的个数。 </li>
<li>firstElementChild：指向第一个子元素；firstChild 的元素版。 </li>
<li>lastElementChild：指向最后一个子元素；lastChild 的元素版。 </li>
<li>previousElementSibling：指向前一个同辈元素；previousSibling 的元素版。 </li>
<li>nextElementSibling：指向后一个同辈元素；nextSibling 的元素版。 </li>
</ul>
<h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><p>HTML5 新增了很多 API，致力于简化 CSS 类的用法。 </p>
<ul>
<li><p>getElementsByClassName()方法：接收一个参数，即一个包含一或多个类名的字符串，返回带有指定类的所有元素的 NodeList。不过注意与使用 getElementsByTagName()有同样的性能问题。</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取得所有类中包含"username"和"current"的元素，类名的先后顺序无所谓 </span></span><br><span class="line"><span class="keyword">var</span> allCurrentUsernames = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"username current"</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//取得 ID 为"myDiv"的元素中带有类名"selected"的所有元素 </span></span><br><span class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).getElementsByClassName(<span class="string">"selected"</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>classList 属性<br>在操作类名时，需要通过 className 属性添加、删除和替换类名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"bd user disabled"</span>&gt;...&lt;<span class="regexp">/div&gt; </span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/删除"user"类 </span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/首先，取得类名字符串并拆分成数组 </span></span><br><span class="line"><span class="regexp">var classNames = div.className.split(/</span>\s+<span class="regexp">/); </span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/找到要删的类名 </span></span><br><span class="line"><span class="regexp">var pos = -1,  </span></span><br><span class="line"><span class="regexp">    i, </span></span><br><span class="line"><span class="regexp">    len; </span></span><br><span class="line"><span class="regexp">for (i=0, len=classNames.length; i &lt; len; i++)&#123; </span></span><br><span class="line"><span class="regexp">    if (classNames[i] == "user")&#123; </span></span><br><span class="line"><span class="regexp">        pos = i; </span></span><br><span class="line"><span class="regexp">        break; </span></span><br><span class="line"><span class="regexp">    &#125; </span></span><br><span class="line"><span class="regexp">&#125; </span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/删除类名 </span></span><br><span class="line"><span class="regexp">classNames.splice(i,1); </span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/把剩下的类名拼成字符串并重新设置 </span></span><br><span class="line"><span class="regexp">div.className = classNames.join(" ");</span></span><br></pre></td></tr></table></figure>
<p>HTML5 新增了一种操作类名的方式，可以让操作更简单也更安全.所有元素添加了classList 属性。前面那么多行代码用下面这一行代码就可以代替了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.classList.remove(<span class="string">"user"</span>);</span><br></pre></td></tr></table></figure>
<p>这个新类型还定义如下方法。 </p>
</li>
<li><p>add(value)：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。 </p>
</li>
<li><p>contains(value)：表示列表中是否存在给定的值，如果存在则返回 true，否则返回 false。</p>
</li>
<li><p>remove(value)：从列表中删除给定的字符串。 </p>
</li>
<li><p>toggle(value)：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除"disabled"类 </span></span><br><span class="line">div.classList.remove(<span class="string">"disabled"</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">//添加"current"类 </span></span><br><span class="line">div.classList.add(<span class="string">"current"</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">//切换"user"类 </span></span><br><span class="line">div.classList.toggle(<span class="string">"user"</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">//确定元素中是否包含既定的类名 </span></span><br><span class="line"><span class="keyword">if</span> (div.classList.contains(<span class="string">"bd"</span>) &amp;&amp; !div.classList.contains(<span class="string">"disabled"</span>))&#123; </span><br><span class="line">    <span class="comment">//执行操作 </span></span><br><span class="line">) </span><br><span class="line"> </span><br><span class="line"><span class="comment">//迭代类名 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len=div.classList.length; i &lt; len; i++)&#123; </span><br><span class="line">    doSomething(div.classList[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除非你需要全部删除所有类名，或者完全重写元素的 class 属性，否则也就用不到 className 属性了。 </p>
</li>
<li><p>焦点管理<br>HTML5 也添加了辅助管理 DOM 焦点的功能。</p>
<ul>
<li>document.activeElement 属性：始终会引用 DOM 中当前获得了焦点的元素</li>
<li>document.hasFocus()方法：用于确定文档是否获得了焦点，true/false</li>
</ul>
</li>
<li><p>HTMLDocument的变化 </p>
<ul>
<li>readyState 属性：使用 document.readyState 的最恰当方式，就是通过它来实现一个指示文档已经加载完成的指示器。</li>
</ul>
</li>
<li><p>插入标记</p>
<ul>
<li>innerHTML 属性 </li>
<li>outerHTML 属性 </li>
<li>insertAdjacentHTML()方法<br>其它略。</li>
</ul>
</li>
</ul>
<h3 id="专有扩展"><a href="#专有扩展" class="headerlink" title="专有扩展"></a>专有扩展</h3><ul>
<li>children属性<br>这个属性是 HTMLCollection 的实例，只包含元素中同样还是元素的子节点。除此之外，children 属性与 childNodes 没有什么区别。</li>
<li>contains()方法：经常需要知道某个节点是不是另一个节点的后代。这个方法接收一个参数，即要检测的后代节点。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="built_in">document</span>.documentElement.contains(<span class="built_in">document</span>.body));    <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li>插入文本 <ul>
<li>innerText 属性 </li>
<li>outerText 属性 </li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Selectors API，定义了两个方法，让开发人员能够基于 CSS 选择符从 DOM 中取得元素，这两个方法是 querySelector()和 querySelectorAll()。 </li>
<li>Element Traversal，为 DOM 元素定义了额外的属性，让开发人员能够更方便地从一个元素跳到另一个元素。之所以会出现这个扩展，是因为浏览器处理 DOM 元素间空白符的方式不一样。 </li>
<li>HTML5，为标准的 DOM 定义了很多扩展功能。其中包括在 innerHTML 属性这样的事实标准基础上提供的标准定义，以及为管理焦点、设置字符集、滚动页面而规定的扩展 API。 </li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack入门</title>
    <url>/2020/04/10/%E6%A1%86%E6%9E%B6-webpack-2020-04-10-Webpack%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>简介：对webpack基础操作的总结。</p>
<a id="more"></a>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li>什么是webpack?<br>webpack是“模块打包机”，本质上就是一个将我们写的模块化代码转成现代浏览器可直接执行的代码。webpack可以为我们整合很多服务。如：<ul>
<li>热更新服务(代码保存自动展现最新代码)</li>
<li>代理服务（调后端接口不跨域）</li>
<li>翻译服务（es6\es7转兼容）</li>
<li>压缩打包服务（项目上线，压缩代码压缩图片）</li>
<li>自动上传服务（自动将静态资源上次CDN）</li>
</ul>
</li>
</ul>
<ul>
<li><p>Source Maps：<br>有时候我们打包后的文件若出错则不容易调试，使用Source Maps能让我们知道对应源代码出错的位置，更容易调试。</p>
</li>
<li><p>Loader:<br>使用loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理。<br>譬如：Sass转css，ES6语法的JS转为浏览器可兼容的JS，React的JSX转为JS<br>用到的工具或脚本：</p>
<ul>
<li>Babel：是一个JS编译平台。作用：让ES6、ES7转为浏览器兼容的语法；可使用拓展的语言，如React的JSX，之后会帮助转为JS。</li>
<li>css-loader 和 style-loader</li>
<li>CSS预处理器：Sass和Less之类的预处理器，是对原生CSS的扩展，能使用类似于variables,nesting,mixins等不存在于css中的特性来写css。CSS预处理器将这些特殊类型语句转化为浏览器能识别的CSS语句。<ul>
<li>常用的CSS预处理器：Less Loader, Sass Loader, Stylus Loader</li>
</ul>
</li>
</ul>
</li>
<li><p>插件(Plugins):<br>插件是用来扩展webpack的功能的，会在整个构建过程中生效，并执行相应的任务。与Loader不同，Loader是对打包构建过程中对源文件进行处理，Plugins是在整个构建过程都起作用。<br>用到的一些插件：</p>
<ul>
<li>HtmlWebpackPlugin：根据模板自动生成index.html；</li>
<li>BannerPlugin：添加版权声明的插件；</li>
<li>Hot Module Replacement：允许修改组件代码后，自动刷新实时预览效果。</li>
</ul>
</li>
<li><p>产品阶段的构建所用的一些优化插件：在产品阶段还需要对打包的文件进行额外的处理，如优化、压缩、缓存、分离CSS和JS。</p>
<ul>
<li>优化插件：OccurenceOrderPlugin（为组件分配ID）、UglifyJsPlugin（压缩JS代码）、ExtractTextPlugin（分离CSS和JS）</li>
<li>缓存：CleanWebpackPlugin（清理build中的残余文件）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="正式使用Webpack"><a href="#正式使用Webpack" class="headerlink" title="正式使用Webpack"></a>正式使用Webpack</h2><p><code>{extry file}出填写入口文件的路径，本文中就是上述main.js的路径，
{destination for bundled file}处填写打包文件的存放路径
填写路径的时候不用添加{}
webpack {entry file} {destination for bundled file}</code><br>这里我无法直接用上面的语句，估计是改了</p>
<p>但可以通过配置文件webpack.config.js中的entry和output，然后在终端使用webpack<br>但依然不行，估计也是改了。</p>
<p>还可以通过npm来引导执行任务，这样就不用输入webpack了：<br>在package.json中对scripts对象进行相关设置：”start”:”webpack”<br>注：package.json中的script会安装一定顺序寻找命令对应位置，本地的node_modules/.bin路径就在这个寻找清单中<br>现在可以通过 npm start 来运行webpack进行打包文件了</p>
<h3 id="生成Source-Maps-（让调试更容易）"><a href="#生成Source-Maps-（让调试更容易）" class="headerlink" title="生成Source Maps （让调试更容易）"></a>生成Source Maps （让调试更容易）</h3><p>在webpack.config.js中配置”devtool”:eval-source-map</p>
<h3 id="使用webpack构建本地服务器"><a href="#使用webpack构建本地服务器" class="headerlink" title="使用webpack构建本地服务器"></a>使用webpack构建本地服务器</h3><p>npm install –save-dev webpack-dev-server<br>把命令加入到webpack.config.js中：<br>devServer: {<br>    contentBase: “./public”,//本地服务器所加载的页面所在的目录<br>    historyApiFallback: true,//不跳转<br>    inline: true//实时刷新<br>  } </p>
<p>在终端输入：npm run server<br>就可以开启本地服务器了！</p>
<p>一般的流程就是：终端输入相应命令安装，然后配置文件webpack.config或是webpack.production.config.js修改\新增对应的配置<br>然后就可以使用了</p>
<h2 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h2><p>通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，<br>比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件<br>对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。</p>
<p>一切皆模块：webpack把所有文件都当作模块来处理，js代码、css和fonts以及图片等都能通过合适的loader来进行处理</p>
<p>CSS: css-loader style-loader</p>
<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>能帮我们完成：使用最新的ES6 ES7的JS代码，而不用管当前使用的浏览器兼容性<br>能让我们使用基于JS的扩展语言，比如React的JSX</p>
<h3 id="CSS-module"><a href="#CSS-module" class="headerlink" title="CSS module"></a>CSS module</h3><p>CSS样式巨大且充满了全局类名，维护和修改很麻烦。于是类似于JS的模块化思想的css modules的技术。通过css模块，所有的类名，动画名默认都只作用于当前模块。<br>webpack对css modules有很好的支持，只需在css loader中进行简单配置即可。</p>
<h3 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h3><p>Sass  Less 是对原生CSS的扩展, 允许我们使用variables,nesting,mixins,inheritance等不存在于css中的特性来写css<br>CSS预处理器会将这些特殊类型的语句转化为浏览器可识别的CSS语句<br>webpack可使用相关的loader进行配置：<br>Less Loader<br>Sass Loader<br>Stylus Loader</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>就是用来拓展webpack的功能，在整个构建过程中都起作用。比如我们可以给打包后的代码添加版权声明的插件。<br>另外还有一些常用的插件：HtmlWebpackPlugin会根据文件模板来帮我们自动生成index.html文件。<br>Hot Module Replacement插件实现了保存后浏览器自动刷新呈现最新数据，可以通过配置babel的对应插件来实现（因为webpack对应的插件比较难配置）</p>
<h3 id="产品阶段的构建"><a href="#产品阶段的构建" class="headerlink" title="产品阶段的构建"></a>产品阶段的构建</h3><p>在产品阶段，可能还需要对打包的文件进行额外的处理，比如优化、压缩、缓存、分离CSS和JS<br>创建一个webpack.production.config.js的文件，和webpack.config.js很像</p>
<h4 id="一些优化插件："><a href="#一些优化插件：" class="headerlink" title="一些优化插件："></a>一些优化插件：</h4><p>OccurenceOrderPlugin :为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID<br>UglifyJsPlugin：压缩JS代码<br>ExtractTextPlugin：分离CSS和JS文件</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>修改webpack.production.config.js中filename:”bundle-[hsah].js”<br>然后 npm run build 就可以在build文件夹中看到bundle-xxxx.js的缓存了<br>但缓存会越来越多，因此需要一个清除残余文件的插件：clean-webpack-plugin<br>然后再修改配置文件中相应的位置</p>
<hr>
<p>参考资料：</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/42e11515c10f" target="_blank" rel="noopener">入门Webpack，看这篇就够了</a><br><a href="https://segmentfault.com/a/1190000015973544" target="_blank" rel="noopener">我们为什么需要webpack</a></p>
</blockquote>
<hr>
<p><a href="https://github.com/codingbylch/DailyLearning" target="_blank" rel="noopener">基于webpack: ^4.42.1的简单demo实践</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS布局相关</title>
    <url>/2020/04/08/CSS%E7%9B%B8%E5%85%B3-2020-04-08-CSS%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>简介：CSS的双飞翼布局、水平垂直居中、Flex布局</p>
<a id="more"></a>

<h2 id="双飞翼-圣杯-布局"><a href="#双飞翼-圣杯-布局" class="headerlink" title="双飞翼(圣杯)布局"></a>双飞翼(圣杯)布局</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>双飞翼、圣杯布局其实实现的都是同样的页面：主页面自适应，两边固定宽度，只是css实现上有一点点不同。</p>
<h3 id="利用flex"><a href="#利用flex" class="headerlink" title="利用flex"></a>利用flex</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span>middle<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-class">.container</span>&#123;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.left</span>&#123;</span><br><span class="line">        <span class="attribute">order</span>: -<span class="number">1</span>; <span class="comment">/*调整left顺序*/</span></span><br><span class="line">        <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: bisque; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.right</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">180px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: chocolate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.middle</span>&#123;</span><br><span class="line">        <span class="attribute">flex-grow</span>:<span class="number">1</span></span><br><span class="line">        background-color: darkcyan;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="利用绝对定位布局"><a href="#利用绝对定位布局" class="headerlink" title="利用绝对定位布局"></a>利用绝对定位布局</h3><p>父元素设置为position:relative,然后left和right设置为position:absolute。这是因为absolute需要针对就近的父元素进行绝对定位，所以要求父元素是relative或者absolute。<br>relative原来的元素不会脱离文档流，可使用top left bottom right相对于原来的位置进行移动，可能会覆盖其它元素。<br>absolute则是以父元素的左上角为参考点，然后使用top left bottom right相对于左上角进行移动。<br>(可以很自由地进行调节，“万金油”)<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200408231733.png" alt="相对定位"><br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200408231708.png" alt="绝对定位"></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-class">.container</span>&#123;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        <span class="comment">/* height: 600px; */</span></span><br><span class="line">        <span class="attribute">background-color</span>: darkgray;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.left</span>&#123;</span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">        <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: bisque; </span><br><span class="line">        <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.right</span>&#123;</span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">180px</span>;</span><br><span class="line">        <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: chocolate;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.middle</span>&#123;</span><br><span class="line">        <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">margin-right</span>: <span class="number">180px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: darkcyan;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Flex布局（来自阮一峰）"><a href="#Flex布局（来自阮一峰）" class="headerlink" title="Flex布局（来自阮一峰）"></a>Flex布局（来自阮一峰）</h2><p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex布局教程：语法篇</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">Flex布局教程：实例篇</a></p>
<h2 id="水平垂直居中实现"><a href="#水平垂直居中实现" class="headerlink" title="水平垂直居中实现"></a>水平垂直居中实现</h2><h3 id="利用Flex"><a href="#利用Flex" class="headerlink" title="利用Flex"></a>利用Flex</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">justify-content</span>:center;</span><br><span class="line">    <span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Class的基本语法</title>
    <url>/2020/04/03/JS%E7%9B%B8%E5%85%B3-2020-04-03-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6-%E7%B1%BB/</url>
    <content><![CDATA[<p>简介：一部分来自深入理解ES6，一部分来自阮一峰的博客。对ES6 新引入的class 进行介绍学习。<br>评价：这本书讲的有点繁琐了，虽是一本好书。</p>
<a id="more"></a>

<h3 id="ES5中的仿类结构"><a href="#ES5中的仿类结构" class="headerlink" title="ES5中的仿类结构"></a>ES5中的仿类结构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonType(<span class="string">"Nicholas"</span>);</span><br><span class="line">person.sayName(); <span class="comment">//	输出	"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonType); <span class="comment">//	true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//	true</span></span><br></pre></td></tr></table></figure>
<p>这种基本模式在许多对类进行模拟的JS库中都存在，而这也是ES6类的出发点。</p>
<h3 id="ES6中的类的声明"><a href="#ES6中的类的声明" class="headerlink" title="ES6中的类的声明"></a>ES6中的类的声明</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//	等价于	PersonType	构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//	等价于	PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">"Nicholas"</span>);</span><br><span class="line">person.sayName(); <span class="comment">//	输出	"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass); <span class="comment">//	true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//	true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass); <span class="comment">//	"function"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName); <span class="comment">//	"function"</span></span><br></pre></td></tr></table></figure>

<h3 id="类与自定义类型之间的区别"><a href="#类与自定义类型之间的区别" class="headerlink" title="类与自定义类型之间的区别"></a>类与自定义类型之间的区别</h3><ol>
<li>类声明不会被提升，与let相似；</li>
<li>类声明中的代码会自动运行在严格模式下，且无法退出严格模式；</li>
<li>类的所有方法都是不可枚举的，自定义函数则可以通过Object.defineProperty()进行方法的枚举；</li>
<li>类的所有方法内部都没有[[Construct]]，因此使用new会抛出错误；</li>
<li>调用类构造器时不使用new；</li>
<li>在类的方法内重写类名，会报错。</li>
</ol>
<p>等价的ES5的类写法，完全可实现ES6的类，但相对繁琐：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	直接等价于	PersonClass</span></span><br><span class="line"><span class="keyword">let</span> PersonType2 = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">"use	strict"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> PersonType2 = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//	确认函数被调用时使用了	new</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Constructor	must	be	called	with	new."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(PersonType2.prototype, <span class="string">"sayName"</span>, &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//	确认函数被调用时没有使用	new</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Method	cannot	be	called	with	new."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PersonType2;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<h3 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayName()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">'Mike'</span>);</span><br><span class="line">person.sayName();</span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass);</span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName);</span><br></pre></td></tr></table></figure>

<h3 id="具名类表达式"><a href="#具名类表达式" class="headerlink" title="具名类表达式"></a>具名类表达式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span> <span class="title">PersonClass2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass); <span class="comment">//	"function"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass2); <span class="comment">//	"undefined"</span></span><br></pre></td></tr></table></figure>

<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>类允许在原型上定义<strong>访问器属性</strong>。创建一个getter，可以使用get关键字；创建setter使用set关键字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHtml</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element)&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> html()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> html(value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.element.innerHTML = value;</span><br><span class="line">    &#125; <span class="comment">// 实际上使用setter 和getter都是可以“隐藏属性”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非类的等价表示如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CustomHtml = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="keyword">const</span> CustomHtml = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Constructor must be called with new.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(CustomHtml.prototype,<span class="string">'html'</span>,&#123;</span><br><span class="line">        enumerable:<span class="literal">false</span>,</span><br><span class="line">        configurable:<span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>:function()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>:function(value)&#123;</span><br><span class="line">            <span class="keyword">this</span>.element.innerHTML = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CustomHtml;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="需计算的成员名"><a href="#需计算的成员名" class="headerlink" title="需计算的成员名"></a>需计算的成员名</h3><p>与对象字面量类似，类方法和类访问器属性都能使用需计算的名称。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">"sayName"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [methodName]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> PersonClass(<span class="string">"Nicholas"</span>);</span><br><span class="line">me.sayName(); <span class="comment">//	"Nicholas"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用计算属性名的好处：当我们进行一个项目开发时（特别是多人项目），要保证命名的可读性和可维护性，这时往往需要进行统一的管理。现在一个常用的方法是使用模块化方法（如ES6模块化规范，CommonJS规范，AMD规范，CMD规范），在一个模块中定义一些常量，并进行统一的导出使用，从而保证变量名良好的维护性：<br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// states.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> states = &#123;</span><br><span class="line">    states1:<span class="string">"start"</span>,</span><br><span class="line">    states2:<span class="string">"doing"</span>,</span><br><span class="line">    states3:<span class="string">"end"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>    <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//other.js</span></span><br><span class="line"><span class="keyword">import</span> STATES <span class="keyword">from</span> <span class="string">'states.js'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [STATES.states1]()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"start~~"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj[STATES.states1]();</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="实例属性的新写法"><a href="#实例属性的新写法" class="headerlink" title="实例属性的新写法"></a>实例属性的新写法</h3><p>属性也可以定义在类的最顶层，其他都不变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span> </span>&#123;</span><br><span class="line">  _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> value() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Getting the current value!'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    <span class="keyword">this</span>._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>如果在一个方法前，加上<strong>static</strong>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure>

<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prop = <span class="number">1</span>; <span class="comment">// 我就是静态属性，不是实例属性</span></span><br><span class="line">Foo.prop <span class="comment">// 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> prop = <span class="number">1</span>; <span class="comment">// 新写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="私有方法和私有属性"><a href="#私有方法和私有属性" class="headerlink" title="私有方法和私有属性"></a>私有方法和私有属性</h3><ul>
<li><p>现有的解决方案（都不保险）：</p>
<ul>
<li>一种做法是在命名上加以区别</li>
<li>一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值</li>
</ul>
</li>
<li><p>私有属性和私有方法的提案<br>方法是在属性名或方法名之前，使用#表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  #a;</span><br><span class="line">  #b;</span><br><span class="line">  <span class="keyword">constructor</span>(a, b) &#123;</span><br><span class="line">    this.#a = a;</span><br><span class="line">    this.#b = b;</span><br><span class="line">  &#125;</span><br><span class="line">  #sum() &#123;</span><br><span class="line">    return #a + #b;</span><br><span class="line">  &#125;</span><br><span class="line">  printSum() &#123;</span><br><span class="line">    console.log(this.#sum());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="new-target-属性"><a href="#new-target-属性" class="headerlink" title="new.target 属性"></a>new.target 属性</h3><p>ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>关于Class的继承，直接看<a href="https://es6.ruanyifeng.com/?search=map&x=9&y=10#docs/class-extends" target="_blank" rel="noopener">阮一峰的博客</a>，如果直接摘抄大可不必记录。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise与异步编程</title>
    <url>/2020/04/02/JS%E7%9B%B8%E5%85%B3-2020-04-02-Promise%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>还没写，占个坑<br>简介：介绍Promise，并理解Promise是如何工作的。</p>
<a id="more"></a>

<h2 id="异步编程的背景"><a href="#异步编程的背景" class="headerlink" title="异步编程的背景"></a>异步编程的背景</h2><p>异步: 某个任务被工作线程执行完毕后, 主线程空闲时调用任务队列中的任务, 并执行响应的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如readFile函数先去读取"example.txt"文件，读取完毕之后才会去执行后面的函数（称作回调函数），这里面的原理级工作机制不需要了解，只需要了解工作流程。</span></span><br><span class="line">readFile(<span class="string">"example.txt"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, contents</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 我是回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(contents);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</span><br></pre></td></tr></table></figure>
<p>但这可能会陷入回调地狱（callback hell），即嵌套了过多回调函数。这会创建错综复杂且难以调试的代码，而且也会存在问题。<br>于是就提出了Promise来改善这些情况。</p>
<h2 id="Promise基础"><a href="#Promise基础" class="headerlink" title="Promise基础"></a>Promise基础</h2><h2 id="全局的Promise拒绝处理"><a href="#全局的Promise拒绝处理" class="headerlink" title="全局的Promise拒绝处理"></a>全局的Promise拒绝处理</h2><h2 id="串联Promise"><a href="#串联Promise" class="headerlink" title="串联Promise"></a>串联Promise</h2><h2 id="响应多个Promise"><a href="#响应多个Promise" class="headerlink" title="响应多个Promise"></a>响应多个Promise</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">'p1'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">'p2'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1,p2]).then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(results);  <span class="comment">// ['p1','p2']</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="继承Promise"><a href="#继承Promise" class="headerlink" title="继承Promise"></a>继承Promise</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的DOM操作方式</title>
    <url>/2020/04/02/JS%E7%9B%B8%E5%85%B3-2020-04-02-%E5%B8%B8%E8%A7%81%E7%9A%84DOM%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>简介：摘选常见的DOM操作方式。</p>
<a id="more"></a>

<h2 id="DOM的四个基本接口"><a href="#DOM的四个基本接口" class="headerlink" title="DOM的四个基本接口"></a>DOM的四个基本接口</h2><p>在DOM接口规范中，有四个基本的接口：Document, Node, NodeList, NamedNodeMap。</p>
<p>Document:Document接口是对文档进行操作的入口，它是从Node接口继承过来的。</p>
<p>Node:Node接口是其他大多数接口的父类。 在DOM树中，Node接口代表了树中的一个节点。</p>
<h2 id="常见的DOM操作"><a href="#常见的DOM操作" class="headerlink" title="常见的DOM操作"></a>常见的DOM操作</h2><ul>
<li><p>查找节点<br>document.getElementById(‘id属性值’); 返回拥有指定id的第一个对象的引用<br>document/element.getElementsByClassName(‘class属性值’); 返回拥有指定class的对象集合<br>document/element.getElementsByTagName(‘标签名’); 返回拥有指定标签名的对象集合<br>document.getElementsByName(‘name属性值’); 返回拥有指定名称的对象结合<br>document/element.querySelector(‘CSS选择器’); 仅返回第一个匹配的元素<br>document/element.querySelectorAll(‘CSS选择器’); 返回所有匹配的元素<br>document.documentElement; 获取页面中的HTML标签<br>document.body; 获取页面中的BODY标签<br>document.all[&#39;&#39;]; 获取页面中的所有元素节点的对象集合型</p>
</li>
<li><p>创建节点<br>document.createElement(‘元素名’); 创建新的元素节点<br>document.createAttribute(‘属性名’); 创建新的属性节点<br>document.createTextNode(‘文本内容’); 创建新的文本节点<br>document.createComment(‘注释节点’); 创建新的注释节点<br>document.createDocumentFragment( ); 创建文档片段节点</p>
</li>
<li><p>删除节点<br>parentNode.removeChild( existingChild );删除已有的子节点，返回值为删除节点<br>element.removeAttribute(‘属性名’);删除具有指定属性名称的属性，无返回值<br>element.removeAttributeNode( attrNode );删除指定属性，返回值为删除的属性</p>
</li>
<li><p>修改节点<br>parentNode.replaceChild( newChild, existingChild );用新节点替换父节点中已有的子节点<br>element.setAttributeNode( attributeName );若原元素已有该节点，此操作能达到修改该属性值的目的<br>element.setAttribute( attributeName, attributeValue );若原元素已有该节点，此操作能达到修改该属性值的目的</p>
</li>
<li><p>插入节点<br>parent.appendChild( element/txt/comment/fragment );向父节点的最后一个子节点后追加新节点<br>parent.insertBefore( newChild, existingChild );向父节点的某个特定子节点之前插入新节点<br>element.setAttributeNode( attributeName );给元素增加属性节点<br>element.setAttribute( attributeName, attributeValue );给元素增加指定属性，并设定属性值</p>
</li>
<li><p>设置样式<br>ele.style.styleName = styleValue;设置ele元素的CSS样式</p>
</li>
</ul>
<h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><ul>
<li><p>鼠标事件有哪些？<br>1、onclick 事件——当用户点击时<br>2、onload 事件——用户进入<br>3、onunload 事件——用户离开，如刷新页面，提交表单，关闭窗口，关闭浏览器时触发（这个事件在Chrome和Opera浏览器里并不支持）<br>4、onmouseover事件——鼠标移入<br>5、onmouseout事件——鼠标移出<br>6、onmousedown事件——鼠标按下<br>7、onmouseup 事件——鼠标抬起</p>
</li>
<li><p>如何获取相邻的节点？<br>neborNode.previousSibling :获取已知节点的相邻的上一个节点<br>nerbourNode.nextSlbling: 获取已知节点的下一个节点</p>
</li>
<li><p>可以复制节点么？<br>cloneNode(true | false);复制某个节点<br>参数：是否复制原节点的所有属性</p>
</li>
</ul>
<h2 id="Dom节点的分类"><a href="#Dom节点的分类" class="headerlink" title="Dom节点的分类"></a>Dom节点的分类</h2><p>childNodes：获取所有节点 包括文本节点<br>节点分为3种类型：<br>1、元素节点<br>2、文本节点 xxx<br>3、属性节点<br>可以通过nodeType这个属性查看节点的类型<br>nodeType == 1 元素<br>nodeType == 2 属性<br>nodeType == 3 文本节点</p>
<p>摘选自：</p>
<ol>
<li><a href="https://blog.csdn.net/weixin_42276859/article/details/80901230" target="_blank" rel="noopener">常见的DOM操作方式有哪些？</a></li>
<li><a href="https://blog.csdn.net/weixin_42276859/article/details/80901230" target="_blank" rel="noopener">DOM的方法</a></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax的一些基本操作</title>
    <url>/2020/04/01/JS%E7%9B%B8%E5%85%B3-2020-04-01-Ajax%E4%B8%8EComet/</url>
    <content><![CDATA[<p>简介：XML的get、post实现，原生ajax的实现、Fetch操作。</p>
<a id="more"></a>

<h3 id="XHLHttpRequest对象"><a href="#XHLHttpRequest对象" class="headerlink" title="XHLHttpRequest对象"></a>XHLHttpRequest对象</h3><p>基本的Ajax请求写法：</p>
<ul>
<li><p>get:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本的Ajax请求写法：</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">'https://www.baidu.com'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomething</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// get</span></span><br><span class="line">    <span class="keyword">let</span> request = <span class="keyword">new</span> XMLHttpRequest; <span class="comment">// 创建XHR对象</span></span><br><span class="line">    request.open(<span class="string">'GET'</span>, url); <span class="comment">// 设置请求类型、请求URL</span></span><br><span class="line">    request.responseType = <span class="string">'text'</span>; <span class="comment">// 设置返回类型</span></span><br><span class="line">    request.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// onload事件，只要浏览器接收到响应就会触发</span></span><br><span class="line">        <span class="comment">// console.log(request.response);</span></span><br><span class="line">        <span class="keyword">if</span> (request.status == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(request.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'fail to access.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    request.send(); <span class="comment">// 开始发送请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>post</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postSomething</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//创建异步对象  </span></span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="comment">//设置请求的类型及url</span></span><br><span class="line">    xhr.open(<span class="string">'post'</span>, url);</span><br><span class="line">    <span class="comment">//post请求一定要添加请求头才行不然会报错</span></span><br><span class="line">    xhr.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    <span class="comment">//发送请求</span></span><br><span class="line">    xhr.send(<span class="string">'name=fox&amp;age=18'</span>); <span class="comment">// 传参数</span></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这步为判断服务器是否正确响应</span></span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>FormData<br>XMLHttpRequest 2级定义了FormData类型。FormData 为序列化表单以及创建与表单格式相同的数据（用于通过 XHR 传输）提供了便利。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData(); </span><br><span class="line">data.append(<span class="string">"name"</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">            alert(xhr.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">"Request was unsuccessful: "</span> + xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">"post"</span>, <span class="string">"postexample.php"</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"user-info"</span>);</span><br><span class="line">xhr.send(<span class="keyword">new</span> FormData(form));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>原生ajax请求实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原生Ajax请求实现：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax_method</span>(<span class="params">url, data, method, success</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 异步对象</span></span><br><span class="line">    <span class="keyword">let</span> ajax = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">//这里暂时没考虑兼容性</span></span><br><span class="line">    <span class="keyword">if</span> (method == <span class="string">'get'</span>) &#123;</span><br><span class="line">        <span class="comment">// get 请求</span></span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            url += <span class="string">'?'</span>;</span><br><span class="line">            url += data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置方法和url</span></span><br><span class="line">        ajax.open(<span class="string">'get'</span>, url);</span><br><span class="line">        ajax.send()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method == <span class="string">'post'</span>) &#123;</span><br><span class="line">        ajax.open(<span class="string">'post'</span>, url);</span><br><span class="line">        <span class="comment">// 设置请求头部</span></span><br><span class="line">        ajax.setRequestHeader(<span class="string">'Content-type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">        <span class="comment">// 判断data</span></span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            ajax.send(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ajax.send();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ajax.send(data ? data : '');</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册事件</span></span><br><span class="line">    ajax.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ajax.readyState == <span class="number">4</span> &amp;&amp; ajax.status == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(ajax.responseText);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 外面可以使用 - 闭包</span></span><br><span class="line">            <span class="comment">// return ajax.responseText;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//若外面可传入一个function作为参数success</span></span><br><span class="line">            success(ajax.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Error'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还可以设置有效时间</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ajax.status != <span class="number">4</span>) &#123;</span><br><span class="line">            ajax.abort(); <span class="comment">// 停止请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">5000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fetch写法：</span></span><br><span class="line"><span class="comment">//fetch中发生了什么：</span></span><br><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    response.text().then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(text);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="跨源资源共享"><a href="#跨源资源共享" class="headerlink" title="跨源资源共享"></a>跨源资源共享</h3><p>CORS（Cross-Origin Resource Sharing，跨源资源共享）是W3C 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。 CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</p>
<ul>
<li><p>IE对CORS的实现<br>微软在 IE8 中引入了 XDR（XDomainRequest）类型。这个对象与 XHR 类似，但能实现安全可靠的跨域通信。<br>使 CSRF（Cross-Site Request Forgery，跨站点请求伪造）和 XSS（Cross-Site Scripting，跨站点脚本）的问题得到了缓解。</p>
</li>
<li><p>其他浏览器对CORS的实现<br>通过 XMLHttpRequest对象实现了对 CORS 的原生支持</p>
</li>
<li><p>为了兼容，跨浏览器的CORS<br>检测 XHR 是否支持 CORS 的最简单方式，就是检查是否存在 withCredentials 属性。再结合检测 XDomainRequest 对象是否存在，就可以兼顾所有浏览器了。 </p>
</li>
<li><p>其它跨域技术</p>
<ul>
<li>图像Ping<br>特点：JS中动态创建图像，使用onload或onerror事件处理程序来接受响应。<br>缺点：1.只能发送GET请求；2.无法访问服务器得响应文本。</li>
<li>JSONP</li>
<li>Comet</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS - 背景与边框</title>
    <url>/2020/03/31/CSS%E7%9B%B8%E5%85%B3-2020-03-31-CSS-%E8%83%8C%E6%99%AF%E4%B8%8E%E8%BE%B9%E6%A1%86/</url>
    <content><![CDATA[<p>简介:介绍CSS-背景与边框。</p>
<a id="more"></a>

<p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200331194350.png" alt="背景与边框"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS - 在CSS中调整大小</title>
    <url>/2020/03/31/CSS%E7%9B%B8%E5%85%B3-2020-03-31-%E5%9C%A8CSS%E4%B8%AD%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<p>简介：理解在CSS中约束物体大小的不同方式</p>
<a id="more"></a>

<h2 id="原始尺寸"><a href="#原始尺寸" class="headerlink" title="原始尺寸"></a>原始尺寸</h2><p>不受CSS影响时HTML元素的固有尺寸。</p>
<h2 id="设置具体的尺寸"><a href="#设置具体的尺寸" class="headerlink" title="设置具体的尺寸"></a>设置具体的尺寸</h2><p>当给元素指定尺寸（然后其内容需要适合该尺寸）时，我们将其称为<strong>外部尺寸</strong>。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200331195010.png" alt=""><br>可能会出现溢出问题。</p>
<h3 id="使用百分数"><a href="#使用百分数" class="headerlink" title="使用百分数"></a>使用百分数</h3><p>指的是父容器宽度的百分数。</p>
<h3 id="把百分数作为内外边距"><a href="#把百分数作为内外边距" class="headerlink" title="把百分数作为内外边距"></a>把百分数作为内外边距</h3><p>把margins和padding设置为百分数的话，你会注意到一些奇怪的表现。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200331195341.png" alt=""><br>当你<strong>用百分数设定内外边距</strong>的时候，值是以内联尺寸进行计算的，也即对于左右书写的语言来说的宽度。在我们的例子里面，所有的内外边距是这一宽度的10%，也就是说，你可以让盒子周围的内外边距大小相同。</p>
<h3 id="min-和max-尺寸"><a href="#min-和max-尺寸" class="headerlink" title="min-和max-尺寸"></a>min-和max-尺寸</h3><p><strong>min-height</strong>和<strong>max-height</strong>让CSS给定一个元素的最大或最小尺寸，使盒子<strong>至少</strong>有个确定的高度。若可容纳内容，则不变，若容纳不下会自动变大。<br>同样的还有min-width和max-width。<strong>max-width</strong>的常见用法为，在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。<br>这个技术是用来<strong>让图片可响应</strong>的，所以在更小的设备上浏览的时候，它们会合适地缩放。但<strong>不能用此技术先载入大原始尺寸</strong>的图片再进行缩放，大图像这会<strong>拖慢加载速度</strong>，正确做法应该准备不同尺寸的图片相应加载并缩放。</p>
<h2 id="视口单位"><a href="#视口单位" class="headerlink" title="视口单位"></a>视口单位</h2><p>视口，即你<strong>在浏览器中看到的部分页面</strong>。在CSS中，我们有与视口尺寸相关的度量单位，即意为<strong>视口宽度的vw单位</strong>，以及意为<strong>视口高度的 vh单位</strong>。使用这些单位，可以让做的东西<strong>随用户视口改变大小</strong>。1vh等于视口高度的1%，1vw则为视口宽度的1%。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200331221606.png" alt="视口单位"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS - 值与单位</title>
    <url>/2020/03/31/CSS%E7%9B%B8%E5%85%B3-2020-03-31-CSS%E7%9A%84%E5%80%BC%E4%B8%8E%E5%8D%95%E4%BD%8D/</url>
    <content><![CDATA[<p>简介：了解CSS属性中使用的不同类型的值和单位。</p>
<a id="more"></a>

<h2 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h2><h3 id="绝对长度单位"><a href="#绝对长度单位" class="headerlink" title="绝对长度单位"></a>绝对长度单位</h3><p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200331185607.png" alt="绝对长度单位"></p>
<h3 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h3><p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200331185642.png" alt="相对长度单位"></p>
<p>ems and rems：<br>em和rem是您在从框到文本调整大小时最常遇到的两个相对长度。<br>概括地说，em单位的意思是“父元素的字体大小”。带有ems类的&lt;ul&gt;内的&lt;li&gt;元素从它们的父元素中获取大小。因此，每一个连续的嵌套级别都会逐渐变大。<br>概括地说，rem单位的意思是“根元素的字体大小”。(“根em”的rem标准。)&lt;ul&gt;内的&lt;li&gt;元素和一个rems类从根元素(&lt;html&gt;)中获取它们的大小。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.ems</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.3em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.rems</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.3rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h2><p>它们总是相对于其他值设置的：例如，如果将元素的字体大小设置为百分比，那么它将是元素父元素字体大小的百分比。如果使用百分比作为宽度值，那么它将是父值宽度的百分比。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span><span class="selector-class">.percent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">90%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，虽然许多值接受长度或百分比，但也有一些值只接受长度。</p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>有些值接受数字，不添加任何单位。如透明度属性(opacity)。</p>
<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><h3 id="十六进制RGB值"><a href="#十六进制RGB值" class="headerlink" title="十六进制RGB值"></a>十六进制RGB值</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#02798b</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#c55da1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RGB-和-RGBA的值"><a href="#RGB-和-RGBA的值" class="headerlink" title="RGB 和 RGBA的值"></a>RGB 和 RGBA的值</h3><p>RGB应纳税额有三个参数，<strong>表示颜色的红色、绿色和蓝色通道值</strong>。<br>RGBA颜色：有第四个值表示颜色的alpha通道，它控制不透明度。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">2</span>, <span class="number">121</span>, <span class="number">139</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">197</span>, <span class="number">93</span>, <span class="number">161</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>RGBA的透明度和opacity属性的区别：RGBA颜色只让你指定的颜色不透明；opacity属性让元素和它里面的所有东西都不透明。</p>
</blockquote>
<h3 id="HSL-和-HSLA-的值"><a href="#HSL-和-HSLA-的值" class="headerlink" title="HSL 和 HSLA 的值"></a>HSL 和 HSLA 的值</h3><p>与RGB相比，HSL颜色模型的支持稍差一些(在旧版本的IE中不支持)。hsl() 函数<strong>接受色调、饱和度和亮度值作为参数</strong>。</p>
<ul>
<li>色调： 颜色的底色。这个值在0和360之间，表示色轮周围的角度。</li>
<li>饱和度： 颜色有多饱和？ 它的值为0 - 100%</li>
<li>亮度：颜色有多亮？ 它从0 - 100%中获取一个值</li>
</ul>
<h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(star.png);</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-position</span>: left <span class="number">40px</span> top <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>rgb()、hsl()、url()都是函数。<br>calc()函数可用于简单的计算：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">20%</span> + <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS - 溢出</title>
    <url>/2020/03/31/CSS%E7%9B%B8%E5%85%B3-2020-03-31-CSS-%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<p>简介：理解溢出和控制溢出的方法</p>
<a id="more"></a>
<p>什么是溢出：溢出是在你往盒子里面塞太多东西的时候发生的，CSS有很多种工具控制溢出。</p>
<p>CSS默认会把内容溢出，而不是隐藏。若隐藏，可能造成数据损失而不被发觉。</p>
<h2 id="overflow属性"><a href="#overflow属性" class="headerlink" title="overflow属性"></a>overflow属性</h2><p>overflow属性是你控制一个元素溢出的方式：visible（可见） 、 hidden（隐藏）、scroll（出现滚动条）、auto（滚动条在溢出时才显示）。<br>可以单单设置为overflow-y: scroll（只在垂直方向出现滚动条）。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS - 层叠与继承、选择器、盒模型</title>
    <url>/2020/03/31/CSS%E7%9B%B8%E5%85%B3-2020-03-31-CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>主要内容：</p>
<ul>
<li>CSS层叠与继承</li>
<li>CSS选择器</li>
<li>CSS盒模型</li>
</ul>
<a id="more"></a>

<h2 id="CSS层叠与继承"><a href="#CSS层叠与继承" class="headerlink" title="CSS层叠与继承"></a>CSS层叠与继承</h2><p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200331145405.png" alt=""></p>
<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200331145433.png" alt=""></p>
<h2 id="块级盒子与内联盒子"><a href="#块级盒子与内联盒子" class="headerlink" title="块级盒子与内联盒子"></a>块级盒子与内联盒子</h2><p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200331145607.png" alt=""></p>
<h2 id="什么是CSS-盒模型"><a href="#什么是CSS-盒模型" class="headerlink" title="什么是CSS 盒模型"></a>什么是CSS 盒模型</h2><p>完整的 CSS 盒模型应用于<strong>块级盒子</strong>，内联盒子只使用盒模型中定义的部分内容。</p>
<h3 id="盒模型的各个部分"><a href="#盒模型的各个部分" class="headerlink" title="盒模型的各个部分"></a>盒模型的各个部分</h3><ul>
<li>Content box: 这个区域是用来显示内容，大小可以通过设置 width 和 height.</li>
<li>Padding box: 包围在内容区域外部的空白区域； 大小通过 padding 相关属性设置。</li>
<li>Border box: 边框盒包裹内容和内边距。大小通过 border 相关属性设置。</li>
<li>Margin box: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 margin 相关属性设置。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200331141129.png" alt="盒模型"></li>
</ul>
<h3 id="标准-standard-盒模型"><a href="#标准-standard-盒模型" class="headerlink" title="标准(standard)盒模型"></a>标准(standard)盒模型</h3><p>计算以下盒子的实际宽度和高，为410px和210px：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">350px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注: margin 不计入实际大小 —— 当然，它会影响盒子在页面所占空间<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200331142349.png" alt="标准盒模型"></p>
</blockquote>
<h3 id="替代-alternate-盒模型"><a href="#替代-alternate-盒模型" class="headerlink" title="替代(alternate)盒模型"></a>替代(alternate)盒模型</h3><p>css还有一个替代盒模型。使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123; </span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200331142327.png" alt="替代盒模型"></p>
<blockquote>
<p>可使用调试工具来查看盒模型。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200331143126.png" alt=""></p>
</blockquote>
<h2 id="外边距，内边距，边框"><a href="#外边距，内边距，边框" class="headerlink" title="外边距，内边距，边框"></a>外边距，内边距，边框</h2><h3 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h3><p>外边距属性值可以为正也可以为负。设置负值会导致和其他内容重叠。<br>可以使用margin属性一次控制一个元素的所有边距，或者单独设置：</p>
<ul>
<li>margin-top</li>
<li>margin-right</li>
<li>margin-bottom</li>
<li>margin-left</li>
</ul>
<p><strong>外边距折叠</strong>：如果你有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小。</p>
<h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>为边框设置样式时，有大量的属性可以使用——有四个边框，每个边框都有样式、宽度和颜色，我们可能需要对它们进行操作。<br>可以使用<strong>border属性</strong>一次设置所有四个边框的宽度、颜色和样式。<br>分别设置每边的宽度、颜色和样式，可以使用：</p>
<ul>
<li>border-top</li>
<li>border-right</li>
<li>border-bottom</li>
<li>border-left</li>
</ul>
<p>设置所有边的颜色、样式或宽度，请使用以下属性：</p>
<ul>
<li>border-width</li>
<li>border-style</li>
<li>border-color</li>
</ul>
<p>设置单边的颜色、样式或宽度，可以使用最细粒度的普通属性之一：</p>
<ul>
<li>border-top-width</li>
</ul>
<h3 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h3><p>与外边距不同，您不能有负数量的内边距，所以值必须<strong>是0或正的值</strong>。应用于元素的任何背景都将显示在内边距后面，内边距通常用于<strong>将内容推离边框</strong>。<br>我们可以使用<strong>padding</strong>简写属性控制元素所有边，或者每边单独使用等价的普通属性：</p>
<ul>
<li>padding-top</li>
</ul>
<h2 id="盒子模型和内联盒子"><a href="#盒子模型和内联盒子" class="headerlink" title="盒子模型和内联盒子"></a>盒子模型和内联盒子</h2><p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200331144920.png" alt="内联盒子"><br>可以看到，宽度和高度被忽略了。外边距、内边距和边框是生效的，但它们不会改变其他内容与内联盒子的关系</p>
<h2 id="使用display-inline-block"><a href="#使用display-inline-block" class="headerlink" title="使用display: inline-block"></a>使用display: inline-block</h2><p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200331145009.png" alt="inline-block"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML - 表单相关</title>
    <url>/2020/03/30/%E5%85%B6%E5%AE%83-2020-03-30-%E5%8F%91%E9%80%81%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>简介：主要内容是表单是如何发送数据的、旧式浏览器表单问题、表单数据校验。</p>
<a id="more"></a>


<h2 id="发送表单数据"><a href="#发送表单数据" class="headerlink" title="发送表单数据"></a>发送表单数据</h2><p>form标签的method处填写，最常见的就是GET方法和POST方法：</p>
<ul>
<li>GET方法：GET方法是浏览器使用的方法，请求服务器返回给定的资源。如果使用该方法发送一个表单，那么发送到服务器的数据将被追加到URL。</li>
<li>POST方法：当使用POST方法提交表单时，没有数据会附加到URL，而是在请求主体中包含了数据：<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200330131629.png" alt="network-monitor"><br>如果要发送大量数据，那么POST方法是首选的，因为一些浏览器限制了URL的大小。而且敏感数据也不应用GET发送。</li>
</ul>
<h2 id="旧式浏览器表单问题"><a href="#旧式浏览器表单问题" class="headerlink" title="旧式浏览器表单问题"></a>旧式浏览器表单问题</h2><p>优雅地降级(Graceful degradation)是web开发者最好的朋友。<br>处理旧式浏览器不仅仅是表单问题。而是一整套技术，先放着。</p>
<h2 id="表单数据校验"><a href="#表单数据校验" class="headerlink" title="表单数据校验"></a>表单数据校验</h2><p>不同类型的表单数据校验：</p>
<ul>
<li><p>客户端校验：发生在浏览器端，表单数据被提交到服务器之前</p>
<table>
<thead>
<tr>
<th>JS校验</th>
<th>HTML5内置校验</th>
</tr>
</thead>
<tbody><tr>
<td>可完全自定义实现方式</td>
<td>无需JS，性能更好，不能自定义实现方式</td>
</tr>
</tbody></table>
</li>
<li><p>服务端校验：发生在浏览器提交数据并被服务端接收以后，将数据写入数据库之前。若没通过校验，则从服务器端返回错误消息，并告诉浏览器端发生错误的具体位置和原因。服务器端的校验是对抗错误/恶意数据的最后防线。</p>
</li>
</ul>
<p><strong>一般将两种校验一起使用</strong>来确保数据的正确性以及安全性。</p>
<h3 id="使用内置表单数据校验"><a href="#使用内置表单数据校验" class="headerlink" title="使用内置表单数据校验"></a>使用内置表单数据校验</h3><p>HTML5 一个特别有用的新功能：可以在不写一行脚本代码的情况下，即对用户的输入进行数据校验，这都是通过<strong>表单元素的校验属性</strong>实现的。</p>
<p>关于在input上的校验：</p>
<ul>
<li>CSS伪类:valid和:invalid可进行特殊样式化：<br>元素通过校验时:valid生效，未通过时:invalid生效。</li>
<li>required属性：当设置此属性时，如果输入为空，该表单将不会提交（并将显示错误消息）。</li>
<li>pattern使用正则表达式：符合规则才会提交。</li>
<li>minlength和maxlength：限制字符输入长度。</li>
<li>无法改变错误信息的显示：因为时HTML5默认的，所以无法使用CSS来改变样式。</li>
</ul>
<p>要自定义消息的外观和文本，需要使用JS。<br>HTML5提供<a href="https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#the-constraint-validation-api" target="_blank" rel="noopener">constraint validation API</a>来检测和自定义表单元素的状态，还可以改变错误信息的文本，比如setCustomValidity()方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> email = <span class="built_in">document</span>.getElementById(<span class="string">"mail"</span>);</span><br><span class="line"></span><br><span class="line">email.addEventListener(<span class="string">"input"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (email.validity.typeMismatch) &#123;</span><br><span class="line">    email.setCustomValidity(<span class="string">"I expect an e-mail, darling!"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    email.setCustomValidity(<span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>支持约束校验的API：button,fieldset,input,output,select,textarea等HTML元素。详细约束校验API及属性、方法请浏览<a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Forms/Data_form_validation#使用_JavaScript校验表单" target="_blank" rel="noopener">使用 JavaScript校验表单</a>。<br>对于旧的浏览器，可使用polyfill来弥补其对约束校验API支持的不足（即考虑兼容性）。<br>form标签的novalidate属性可关闭浏览器的自动校验。</p>
<ul>
<li>不使用内建 API 时的表单校验<br>有时，例如使用旧版浏览器或自定义小部件，您将无法（或不希望）使用约束校验API。 在这种情况下，您仍然可以使用 JavaScript 来校验您的表单。<br>要校验表单，您必须问自己几个问题：<ul>
<li>我应该进行什么样的校验？</li>
<li>如果表单校验失败，我该怎么办?</li>
<li>如何帮助用户纠正无效数据?</li>
</ul>
</li>
</ul>
<p>建立自己的校验系统并不难。 <strong>困难的部分是使其足够通用</strong>，以跨平台和任何形式使用它可以创建。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML - 互联网是如何工作的</title>
    <url>/2020/03/30/%E5%85%B6%E5%AE%83-2020-03-30-%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
    <content><![CDATA[<p>简介：互联网是如何工作的。</p>
<a id="more"></a>

<h2 id="互联网是如何工作的"><a href="#互联网是如何工作的" class="headerlink" title="互联网是如何工作的"></a>互联网是如何工作的</h2><p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200330092934.png" alt="最开始电脑间用一根网线连接"></p>
<p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200330093015.png" alt="若多台电脑情况会变得复杂"></p>
<p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200330093044.png" alt="于是需要路由器来帮忙"></p>
<p>路由器的作用：减少链路两两互联的情况，用转发代替互联。</p>
<p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200330093227.png" alt="多个路由器一起帮忙，组成互联网的基础"><br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200330093251.png" alt="使用调制解调器"><br>调制解调器：把网络信息变成电话设施可以处理的信息。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200330093342.png" alt="由ISP将你的信息发送给特定的电脑"><br>互联网服务提供商（ISP）：一家可以管理一些特殊的路由器的公司，这些路由器连接其他ISP的路由器。当我们想把自己的信息发送给别人，需要将自己的网络连接到ISP，由ISP帮助发送到相应的网络。<br>别人或者说别人的电脑如何表示：使用<strong>IP</strong>表示，IP记不住那就用更加容易阅读的<strong>域名</strong>。</p>
<p>互联网（Internet）和网络(Web)是不同的概念：互联网是一种基础技术，将成千上万的设备相互连接；网络是建立在互联网基础之上的服务，这种服务由网络服务器（Web Servers）所提供。</p>
<h2 id="万维网是如何工作的"><a href="#万维网是如何工作的" class="headerlink" title="万维网是如何工作的"></a>万维网是如何工作的</h2><p>客户端：用户设备；<br>服务器：其实就是存储网页、站点和应用的计算机。<br>通俗讲，就是顾客与商店。另外还需了解：</p>
<ul>
<li>网络连接：允许在互联网上发送和接收数据。（去商店的路）</li>
<li>TCP/IP：定义数据如何传输的通信协议。（你去商店需要乘坐出租车还是地铁）</li>
<li>DNS：域名系统。IP地址记不住，域名来凑。域名通过DNS解析为IP地址。（搜索商店名字，得到商店地址，然后准备前往）</li>
<li>HTTP： 超文本传输协议是一个定义客户端和服务器间交流的语言的协议（protocol）。（你和服务员交流的语言）</li>
<li>组成文件：一个网页由许多文件组成。这些文件有两种类型：1）代码：HTML、CSS、JavaScript；资源：其它组成网页的集合：图形、音乐、视频、文档等。</li>
</ul>
<p>当你在浏览器里输入一个网址，发生了什么：</p>
<ol>
<li>浏览器在域名系统（DNS）服务器上找出存放网页的服务器的实际地址（找出商店的位置）。</li>
<li>浏览器发送 HTTP 请求信息到服务器来请拷贝一份网页到客户端（你走到商店并下订单）。这条消息，包括其他所有在客户端和服务器之间传递的数据都是通过互联网使用 TCP/IP 协议传输的。</li>
<li>服务器同意客户端的请求后，会返回一个“200 OK”信息，意味着“你可以查看这个网页，给你～”，然后开始将网页的文件以数据包的形式传输到浏览器（商店给你商品，你将商品带回家）。</li>
<li>浏览器将数据包聚集成完整的网页然后将网页呈现给你（商品到了你的门口 —— 新东西，好棒！）。</li>
</ol>
<h2 id="什么是网络服务器"><a href="#什么是网络服务器" class="headerlink" title="什么是网络服务器"></a>什么是网络服务器</h2><p>简单来讲，就是存放数据供客户端读取的计算机。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200330103303.png" alt=""><br>要发布一个网站，有静态或动态网络服务器：</p>
<ul>
<li>静态网络服务器（static web server）：就一个网页</li>
<li>动态网络服务器（dynamic web server）：网页+数据库</li>
</ul>
<h2 id="DNS请求时如何工作的"><a href="#DNS请求时如何工作的" class="headerlink" title="DNS请求时如何工作的"></a>DNS请求时如何工作的</h2><ol>
<li>在你的浏览器地址栏输入mozilla.org。</li>
<li>您的浏览器询问您的计算机是否已经识别此域名所确定的IP地址（使用本地DNS缓存）。 如果是的话，这个域名被转换为IP地址，然后浏览器与网络服务器交换内容。结束。</li>
<li>如果你的电脑不知道 mozilla.org 域名背后的IP, 它会询问一个DNS服务器，这个服务器的工作就是告诉你的电脑已经注册的域名所匹配的IP。</li>
<li>现在电脑知道了要请求的IP地址，你的浏览器能够与网络服务器交换内容。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/DNS.png" alt="流程"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML - HTML表单基础</title>
    <url>/2020/03/30/%E5%85%B6%E5%AE%83-2020-03-30-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE-HTML%E8%A1%A8%E5%8D%95/</url>
    <content><![CDATA[<p>简介：MDN中的教程 - 关于《HTML表单基础》的学习笔记</p>
<a id="more"></a>

<p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/HTML%E8%A1%A8%E5%8D%95.png" alt="HTML表单"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS - CSS入门</title>
    <url>/2020/03/28/CSS%E7%9B%B8%E5%85%B3-2020-03-28-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE-CSS%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>简介：MDN中的教程 - 关于《CSS First Step》的学习笔记</p>
<a id="more"></a>

<p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200328131125.png" alt=""><br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/Snipaste_2020-03-28_13-32-23.png" alt=""><br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200328133257.png" alt=""></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML - HTML介绍与入门</title>
    <url>/2020/03/28/%E5%85%B6%E5%AE%83-2020-03-28-HTML%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>简介：MDN中的教程 - 关于《HTML介绍》的学习笔记</p>
<a id="more"></a>

<p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200328120006.png" alt="HTML入门"><br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200328120101.png" alt="HTML元数据"><br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200328120137.png" alt="文字处理基础"><br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200328120238.png" alt="建立超链接"><br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200328120416.png" alt="高阶文字排版"><br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200328120531.png" alt="文档与网站架构"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>第二部分 - this和对象原型</title>
    <url>/2020/03/27/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB-%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS-2020-03-27-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<p>主要内容：</p>
<ul>
<li>关于this</li>
<li>this全面解析</li>
<li>对象</li>
<li>混合对象“类”</li>
<li>原型</li>
<li>行为委托</li>
</ul>
<h2 id="第一章-关于this"><a href="#第一章-关于this" class="headerlink" title="第一章 - 关于this"></a>第一章 - 关于this</h2><p>关于this的相关知识还可以查阅《JS高级程序设计》第五章，博客的搜索功能可以搜索得到。</p>
<h3 id="为什么要使用this"><a href="#为什么要使用this" class="headerlink" title="为什么要使用this"></a>为什么要使用this</h3><p>来看两段代码的对比：<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200327163840.png" alt=""><br>解释：如果不适用this，则需要给identify()显示传入一个上下文对象。然而this使用了更加优雅的方式来隐式“传递”一个对象引用，这使得API的设计能够更加简洁易用。</p>
<h3 id="关于对this的误解"><a href="#关于对this的误解" class="headerlink" title="关于对this的误解"></a>关于对this的误解</h3><p>两种对this的错误解释：</p>
<ol>
<li>指向自身</li>
<li>this 指向函数的作用域：某种情况下是对的，某种情况是错的。<br>来看下面一段代码：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.bar(); <span class="comment">// 这是无法成功的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>
每当你想要把 this 和词法作用域的查找混合使用时，一定要提醒自己，这是无法实现的。</li>
</ol>
<h3 id="this到底是个啥"><a href="#this到底是个啥" class="headerlink" title="this到底是个啥"></a>this到底是个啥</h3><p>this是在运行时进行绑定的。<br>this的绑定和函数声明的位置没有任何关系，它指向什么完全取决于函数在哪里被调用。<br>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。</p>
<h2 id="第二章-this全面解析"><a href="#第二章-this全面解析" class="headerlink" title="第二章 this全面解析"></a>第二章 this全面解析</h2><h3 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h3><p>最重要的就是<strong>分析调用栈</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz </span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置是全局作用域 </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"baz"</span>);</span><br><span class="line">    bar(); <span class="comment">// &lt;-- bar 的调用位置 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 当前调用栈是 baz -&gt; bar </span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在 baz 中 </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line">    foo(); <span class="comment">// &lt;-- foo 的调用位置 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是 baz -&gt; bar -&gt; foo </span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在 bar 中 </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">&#125;</span><br><span class="line">baz(); <span class="comment">// &lt;-- baz 的调用位置</span></span><br></pre></td></tr></table></figure>
<h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><p>四条绑定规则。</p>
<ol>
<li><p>默认绑定<br>默认绑定到全局对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">99</span></span><br><span class="line">foo() <span class="comment">// 99</span></span><br></pre></td></tr></table></figure>
<p>使用严格模式，全局对象将无法使用默认绑定。</p>
<blockquote>
<p>在使用第三方库时，注意严格与非严格代码的兼容性。</p>
</blockquote>
</li>
<li><p>隐式绑定</p>
</li>
</ol>
<p><strong>是什么</strong>：调用位置若有上下文对象，隐式规则将会把函数调用中的this绑定到这个上下文对象中，且是最近的那个上下文对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">42</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line">obj1.obj2.foo(); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p><strong>注意隐式丢失</strong>：<br>例子1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数别名！bar实际引用的是foo函数本身</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// a 是全局对象的属性 </span></span><br><span class="line">bar(); <span class="comment">// "oops, global"</span></span><br></pre></td></tr></table></figure>
<p>例子2：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// fn其实引用的是 foo </span></span><br><span class="line"></span><br><span class="line">    fn(); <span class="comment">// &lt;-- 调用位置！ </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// a 是全局对象的属性 </span></span><br><span class="line">doFoo(obj.foo); <span class="comment">// "oops, global"</span></span><br><span class="line">setTimeout(obj.foo, <span class="number">100</span>); <span class="comment">// "oops, global"</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>显式绑定<br>call(..)和apply(..)方法用于显式绑定。但无法解决隐式丢失的问题。<br>但显示绑定的硬绑定可以解决：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    foo.call(obj);</span><br><span class="line">&#125;</span><br><span class="line">bar();  <span class="comment">// 2</span></span><br><span class="line">setTimeout(bar,<span class="number">1000</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 硬绑定的 bar 不可能再修改它的 this </span></span><br><span class="line">bar.call(<span class="built_in">window</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>还可以使用bind(..)函数： var bar = foo.bind(obj);<br>很多第三方库的内置函数都提供一个可选的“上下文”参数，作用等于bind(..)。</p>
</li>
<li><p>new绑定<br>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p>
<ul>
<li>创建（或者说构造）一个全新的对象。</li>
<li>这个新对象会被执行 [[ 原型 ]] 连接。</li>
<li>这个新对象会绑定到函数调用的 this。</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li>
</ul>
</li>
</ol>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>如果某个调用位置可以应用多条规则该怎么办？这时候就需要考虑优先级。<br>new绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
<h3 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h3><p>若把null、undefined作为绑定对象传入call、apply、bind，这些值在调用时会被忽略，则实际应用的是默认绑定规则。<br>那什么情况下会传入null呢：常见的做法是使用apply(…)来展开一个数组并将其当作参数传入一个函数；bind(…)可以对参数进行柯里化（预先设置一些参数）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a+b+c);</span><br><span class="line">&#125;</span><br><span class="line">sum.apply(<span class="literal">null</span>,[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = sum.bind(<span class="literal">null</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment">// 柯里化</span></span><br><span class="line">bar(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在ES6中，可以使用…操作符来代替apply(…)来展开数组：如foo(…[1,2])和foo(1,2)是一样的，这样可以避免不必要的this绑定。<br>注意使用apply来展开数组时，若忽略了this的绑定可能会导致难以分析和追踪的Bug。<br>只是一个小小建议：为了一个更安全的this，可以创建“DMZ”对象：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们的 DMZ 空对象 </span></span><br><span class="line"><span class="keyword">var</span> ø = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 把数组展开成参数 </span></span><br><span class="line">foo.apply(ø, [<span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// a:2, b:3</span></span><br></pre></td></tr></table></figure>

<h4 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h4><p>“间接引用”时，调用这个函数会应用默认绑定规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    a: <span class="number">3</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">    a: <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line">o.foo(); <span class="comment">// 3 </span></span><br><span class="line">(p.foo = o.foo)(); <span class="comment">// 2 间接引用（隐式绑定丢失）</span></span><br></pre></td></tr></table></figure>

<h4 id="软绑定（看看其他资料）"><a href="#软绑定（看看其他资料）" class="headerlink" title="软绑定（看看其他资料）"></a>软绑定（看看其他资料）</h4><p>硬绑定会降低函数的灵活性：使用了硬绑定之后就无法使用隐式绑定或者显示绑定来修改this了。<br>软绑定：给默认绑定指定一个全局对象或undefined，可实现与硬绑定相同的效果，同时可被修改this：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.softBind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 捕获所有 curried 参数 </span></span><br><span class="line">        <span class="keyword">var</span> curried = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(</span><br><span class="line">                (!<span class="keyword">this</span> || <span class="keyword">this</span> === (<span class="built_in">window</span> || global)) ?</span><br><span class="line">                obj : <span class="keyword">this</span></span><br><span class="line">                curried.concat.apply(curried, <span class="built_in">arguments</span>) <span class="comment">//有错误</span></span><br><span class="line">            );</span><br><span class="line">        &#125;;</span><br><span class="line">        bound.prototype = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">        <span class="keyword">return</span> bound;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h3>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>你不知道的JS</tag>
      </tags>
  </entry>
  <entry>
    <title>第一部分 - 作用域和闭包</title>
    <url>/2020/03/27/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB-%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS-2020-03-27-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>主要内容:</p>
<ul>
<li>作用域是什么</li>
<li>此法作用域</li>
<li>函数作用域和块作用域</li>
<li>提升</li>
<li>作用域闭包</li>
</ul>
<h2 id="第一章-作用域是什么"><a href="#第一章-作用域是什么" class="headerlink" title="第一章 - 作用域是什么"></a>第一章 - 作用域是什么</h2><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>JavaScript 引擎进行编译的步骤和传统的编译语言非常相似。简单地说，任何 JavaScript 代码片段<strong>在执行前都要进行编译</strong>（通常就在执行前）。在作用域的背后，用了<strong>很多优化</strong>来保证性能最佳。</p>
<h3 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h3><p>LHS查询：可以理解为赋值；<br>RHS查询：可以理解为取值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;  <span class="comment">//LHS</span></span><br><span class="line">    <span class="keyword">var</span> b = a;  <span class="comment">//LHS,RHS</span></span><br><span class="line">    <span class="keyword">return</span> a + b; <span class="comment">// RHS,RHS</span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> c = foo( <span class="number">2</span> ); <span class="comment">//LHS, RHS(focus foo(...))</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h3><p><strong>什么是作用域嵌套</strong>：一个块或函数在另外一个作用域中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 我是函数里面的作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在当前作用域内找不到变量的声明，那就会到外面的作用域去找。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>ReferenceError：找不到变量的声明；<br>TypeError：找到了变量但操作不当。</p>
<h2 id="第二章-词法作用域"><a href="#第二章-词法作用域" class="headerlink" title="第二章 - 词法作用域"></a>第二章 - 词法作用域</h2><p>作用域层层嵌套，通常会<strong>从内到外</strong>进行变量的查找，作用于的查找在找到第一个匹配的变量就会停止（<strong>遮蔽效应</strong>）。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200327014629.png" alt="作用域“气泡”"></p>
<h3 id="欺骗词法（不要使用with和eval）"><a href="#欺骗词法（不要使用with和eval）" class="headerlink" title="欺骗词法（不要使用with和eval）"></a>欺骗词法（不要使用with和eval）</h3><p>JS有两种机制来实现欺骗词法作用域的目的，但都会导致性能的下降。<br><strong>什么是eval</strong>：eval(…)函数可以接受一个字符串为参数，将其当成就在此处写的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">eval</span>( str ); <span class="comment">// 欺骗！ </span></span><br><span class="line">    <span class="built_in">console</span>.log( a, b ); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>; </span><br><span class="line"> </span><br><span class="line">foo( <span class="string">"var b = 3;"</span>, <span class="number">1</span> ); <span class="comment">// 1, 3</span></span><br></pre></td></tr></table></figure>
<p><strong>何时用eval</strong>：eval(..) 通常被用来执行动态创建的代码。无论何种情况，eval(..) 都可以在运行期修改书写期的词法作用域。严格模式中，eval(..) 在运行时有其自己的词法作用域：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str</span>) </span>&#123; </span><br><span class="line"><span class="meta">    "use strict"</span>; </span><br><span class="line">    <span class="built_in">eval</span>( str ); </span><br><span class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// ReferenceError: a is not defined </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">foo( <span class="string">"var a = 2"</span> );</span><br></pre></td></tr></table></figure>
<p>不建议在setTimeout(…)、setInterval(…)和new Function(..)的第一个参数用字符串。</p>
<p><strong>什么是with</strong>：with也是一个用于欺骗词法作用域的关键字。<strong>with 通常被当作重复引用同一个对象中的多个属性的快捷方式</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    a: <span class="number">1</span>, </span><br><span class="line">    b: <span class="number">2</span>, </span><br><span class="line">    c: <span class="number">3</span> </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 单调乏味的重复 "obj" </span></span><br><span class="line">obj.a = <span class="number">2</span>; </span><br><span class="line">obj.b = <span class="number">3</span>; </span><br><span class="line">obj.c = <span class="number">4</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 简单的快捷方式 </span></span><br><span class="line"><span class="keyword">with</span> (obj) &#123; </span><br><span class="line">    a = <span class="number">3</span>; </span><br><span class="line">    b = <span class="number">4</span>; </span><br><span class="line">    c = <span class="number">5</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但可能会出现以下情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">with</span> (obj) &#123; </span><br><span class="line">        a = <span class="number">2</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> o1 = &#123; </span><br><span class="line">    a: <span class="number">3</span> </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> o2 = &#123; </span><br><span class="line">    b: <span class="number">3</span> </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">foo( o1 ); </span><br><span class="line"><span class="built_in">console</span>.log( o1.a ); <span class="comment">// 2 </span></span><br><span class="line"> </span><br><span class="line">foo( o2 ); </span><br><span class="line"><span class="built_in">console</span>.log( o2.a ); <span class="comment">// undefined </span></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2——不好，a 被泄漏到全局作用域上了！</span></span><br></pre></td></tr></table></figure>
<p>可以注意到一个奇怪的副作用，实际上 a = 2 赋值操作创建了一个全局的变量 a。why?????<br><strong>解释</strong>：with 声明实际上会根据你传递给它的对象凭空创建一个全新的词法作用域。那么当o2传进去，则有一个o2专属的作用域。但o2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此执行a=2时，就会自动创建一个全局变量（非严格）。</p>
<blockquote>
<p>不推荐使用eval和with，且严格模式下with被完全禁止，eval也受限。</p>
</blockquote>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>欺骗词法通过在运行时修改或创建新的作用域，以此来欺骗其它已被定义的作用域。<br><strong>有什么影响</strong>：这会影响JS在编译阶段对代码的性能优化：当代码中出现的eval或with，关于标识符位置的判断优化就会无效。最坏的情况就是所有优化可能都无效，因为eval和with之后所带进来的代码不确定，对作用域的修改也不确定，那只能放弃性能优化。</p>
<h2 id="第三章-函数作用域和块作用域"><a href="#第三章-函数作用域和块作用域" class="headerlink" title="第三章 - 函数作用域和块作用域"></a>第三章 - 函数作用域和块作用域</h2><p><strong>疑问</strong>：是什么生成作用域气泡？只有函数才会生成新的气泡吗？JS中的其它结构能否生成新气泡？</p>
<h3 id="函数中的作用域"><a href="#函数中的作用域" class="headerlink" title="函数中的作用域"></a>函数中的作用域</h3><p>每声明一个函数就会创建一个新气泡。<br><strong>函数作用域的含义</strong>：属于函数作用域内的变量都可以在整个函数作用域内使用（嵌套在里面的作用域也可以使用（因为由内往外））。</p>
<h3 id="隐藏内部实现（一种规范叭）"><a href="#隐藏内部实现（一种规范叭）" class="headerlink" title="隐藏内部实现（一种规范叭）"></a>隐藏内部实现（一种规范叭）</h3><p>使用函数声明把变量和函数都包裹起来，那这种“隐藏”有什么作用？<br>解释：</p>
<ol>
<li>最小授权或最小暴露原则，避免被外部以非预期的方式使用。</li>
<li>可以规避同名标识符之间的冲突。</li>
</ol>
<p>如何规避冲突：1.本地变量声明；2.采用完全不同的变量名称（标识符名称）</p>
<p>使用情景：1.全局命名空间（如对象不想将标识符暴露在全局作用域中）；2.模块管理</p>
<h3 id="函数作用域与立即函数表达式"><a href="#函数作用域与立即函数表达式" class="headerlink" title="函数作用域与立即函数表达式"></a>函数作用域与立即函数表达式</h3><p>将任意代码用函数声明包装起来，则外部作用域无法访问里面的内容。<br><strong>疑问</strong>：解决了一部分问题也带来了新的问题，就是所声明的函数名称会”污染“所在的作用域。<br><strong>如何解决</strong>：立即函数表达式。</p>
<p><strong>立即函数表达式IIFE（Immediately Invoked Function Expression）</strong>：<br>立即函数表达式的通用写法：(function fn(){…})();<br>这里的fn被绑定在函数表达式自身的函数中而不是所在作用域中，从而实现”无污染“，也就是说，所在作用域是没有机会访问该函数的。</p>
<ul>
<li><p>IIFE用法一：匿名函数表达式：(function(){…})()</p>
</li>
<li><p>IIFE用法二：传递参数并当作函数调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">global</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 3 </span></span><br><span class="line">    <span class="built_in">console</span>.log(global.a); <span class="comment">// 2 </span></span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// </span></span><br><span class="line"><span class="comment">// 这对改进代码风格有帮助</span></span><br></pre></td></tr></table></figure>
<p>这个模式的另外一个应用场景是解决 undefined 标识符的默认值被错误覆盖导致的异常（很不常见，除非恶意挖坑..）</p>
</li>
<li><p>IIFE用法三：倒置代码的运行顺序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">def</span>) </span>&#123;</span><br><span class="line">    def(<span class="built_in">window</span>);</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params">global</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 3 </span></span><br><span class="line">    <span class="built_in">console</span>.log(global.a); <span class="comment">// 2 </span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种模式在UMD（Universal Module Definition）项目中被广泛使用。</p>
</li>
</ul>
<h3 id="匿名和具名"><a href="#匿名和具名" class="headerlink" title="匿名和具名"></a>匿名和具名</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// Uncaught SyntaxError: Unexpected token (，无效的语法错误的函数声明</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)() <span class="comment">//ok, 这是函数表达式</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>上面反映了函数表达式可以匿名，但函数声明不可以忽略函数名，这在JS是非法的。<br><strong>匿名函数的缺点</strong>：</p>
<ul>
<li>在栈追踪中不会显示有意义的函数名，调试困难。</li>
<li>在递归中当函数引用自身时只能使用arguments.callee（为何已过期）；另外在事件触发后则无法解绑事件监听器。</li>
<li>可读性下降。</li>
</ul>
<h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>除了函数作用域以外，还有其它类型的作用域：块作用域。<br>var所声明的变量在for、if中与所在作用域的其它地方声明是一样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 1~9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>开发者原意只想让i在for的块作用域内生效，但这里的i”污染“了整个作用域。怎么解决整个问题呢？表面上看 JavaScript 并没有块作用域的相关功能。</p>
<h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>with是块作用域的一种形式：使用with从对象中创建的作用域仅在with声明的作用域中有效。</p>
<h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h4><p>ES3中try/catch的catch分局会创建一个块作用域，声明的变量只在该作用域内有效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="literal">undefined</span>(); <span class="comment">// 执行一个非法操作来强制制造一个异常 </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 能够正常执行！ </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(err); <span class="comment">// ReferenceError: err not found</span></span><br></pre></td></tr></table></figure>

<h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>ES6引入let：可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。let无法变量提升。<br>隐式与显式：在已存在的{…}内使用let声明变量，是隐式的，如果不小心移动到其它块中，可能就会导致错误。可以为let创建显式的块作用域（即使用{..}将包含let的一部分代码括号起来）</p>
<ul>
<li><p>垃圾收集<br>块作用域还和闭包、垃圾回收机制有关。使用块作用域，可以让引擎清楚地知道没有必要继续保存 someReallyBigData了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在这里做点有趣的事情 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这个块中定义的内容可以销毁了！ </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> someReallyBigData = &#123;</span><br><span class="line">        ..</span><br><span class="line">    &#125;;</span><br><span class="line">    process(someReallyBigData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"my_button"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"button clicked"</span>);</span><br><span class="line">&#125;, <span class="comment">/*capturingPhase=*/</span> <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>let循环<br>每个迭代进行重新绑定，确保能够重新赋值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>也可创建块作用域，值是固定常量。</p>
<h2 id="第四章-提升"><a href="#第四章-提升" class="headerlink" title="第四章 - 提升"></a>第四章 - 提升</h2><p>问题：先有声明还是先有赋值？<br>结论：先有声明后有赋值。</p>
<ul>
<li><p>变量声明提升：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>对上面代码的解释：JS会在解释代码之前先编译，编译的工作之一就是找出所有声明，并用合适的作用域关联起来。var a = 2将被看成两个声明：var a和a = 2。编译阶段进行定义声明，第二个赋值声明则等待执行。<br>于是第一段代码可以看作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a; </span><br><span class="line">a = <span class="number">2</span>; </span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数声明也会被提升，但是函数表达式却不会被提升：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo(); <span class="comment">// 不是 ReferenceError, 而是 TypeError! </span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h3><p>函数在变量之前先被提升。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo(); <span class="comment">// 1 </span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>避免重复声明。</p>
<h2 id="第五章-作用域闭包"><a href="#第五章-作用域闭包" class="headerlink" title="第五章 - 作用域闭包"></a>第五章 - 作用域闭包</h2><p><strong>闭包定义</strong>：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使<strong>函数是在当前词法作用域之外执行</strong>。<br>词法作用域的查找规则也是闭包的一部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a); <span class="comment">// 2 </span></span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>但这无法清晰地展示闭包，确切地说<strong>这不是闭包</strong>。<br>下段代码可以清晰地展示闭包：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="built_in">console</span>.log( a ); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> bar; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> baz = foo(); </span><br><span class="line">baz(); <span class="comment">// 2 —— 朋友，这就是闭包的效果。</span></span><br></pre></td></tr></table></figure>
<p>原本foo()执行完之后，其内部作用域也应随之而被销毁。但内部函数bar()被引用，阻止了回收。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。<br>这也是闭包：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x) <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    c(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    fn(); <span class="comment">// 妈妈快看呀，这就是闭包！</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure>
<p>无论什么手段将内部函数传递到所外词法作用域之外，都会持有对原始定义作用域的引用，无论何时执行这个函数都会使用闭包。<br>（表面上看：外部可以访问一个函数内部作用域里的函数，而这个内部函数又有对所在作用域变量的引用，那就使用了闭包）</p>
<p>来看setTimeout的<strong>例子</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(message)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait(<span class="string">'hello world.'</span>)</span><br></pre></td></tr></table></figure>
<p>这里的timer就是wait()函数的内部函数，且持有对messge的引用，内部工具函数setTimeout(…)引用了timer()这个函数。这就是闭包。<br>在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！<br>IIFE严格上来说不算闭包。</p>
<h3 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h3><p>来看一段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="comment">// 6,6,6,6,6</span></span><br></pre></td></tr></table></figure>
<p>由于setTimeout使得回调函数是在循环结束之后才调用的，这导致这些回调函数都在调用同一个i的引用，但实际上我们想要回调函数各自捕获一个i的副本。<br>如何解决：使用IIFE并在每次迭代储存i的值，可以这么写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j);</span><br><span class="line">        &#125;, j * <span class="number">1000</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>什么是模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 外部封闭函数</span></span><br><span class="line">    <span class="keyword">var</span> something = <span class="string">"cool"</span>;</span><br><span class="line">    <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 内部函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(something);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(another.join(<span class="string">" ! "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 返回必须至少有一个内部函数</span></span><br><span class="line">        doSomething: doSomething, </span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = CoolModule();</span><br><span class="line">foo.doSomething(); <span class="comment">// cool </span></span><br><span class="line">foo.doAnother(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>
<p>这种模式被称为模块。模块模式必须具备两个条件：1.必须具有外部封闭函数且至少被调用一次；2.封闭函数至少返回一个内部函数，这样才能形成闭包。</p>
<h4 id="现代的模块机制"><a href="#现代的模块机制" class="headerlink" title="现代的模块机制"></a>现代的模块机制</h4><p>大多数模块依赖加载器 / 管理器本质上都是将这种模块定义封装进一个友好的 API。这里介绍一下核心概念：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyModules = (<span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> modules = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name, deps, impl</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; deps.length; i++) &#123;</span><br><span class="line">            deps[i] = modules[deps[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        modules[name] = impl.apply(impl, deps); <span class="comment">//如果不理解apply，复习一下</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modules[name];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        define: define,</span><br><span class="line">        <span class="keyword">get</span>: <span class="keyword">get</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="未来的模块机制"><a href="#未来的模块机制" class="headerlink" title="未来的模块机制"></a>未来的模块机制</h4><p>先略过。</p>
<h2 id="附录A-动态作用域"><a href="#附录A-动态作用域" class="headerlink" title="附录A - 动态作用域"></a>附录A - 动态作用域</h2><p>词法作用域：JS的作用域是词法作用域，词法作用域最重要的特征是它的定义过程发生在代码的书写阶段（假设你没有使用eval() 或 with）。</p>
<p>动态作用域：并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。</p>
<p>this的机制很像动态作用域。</p>
<h2 id="附录B-块作用域的替代方案"><a href="#附录B-块作用域的替代方案" class="headerlink" title="附录B - 块作用域的替代方案"></a>附录B - 块作用域的替代方案</h2><p>有些浏览器还不支持ES6，为了兼容性则需要有块作用域的替代方案。实际上，使用代码转换工具来对 ES6 代码进行处理，生成兼容 ES5的代码即可。如google的 Traceur 的项目。</p>
<h2 id="附录C-this词法"><a href="#附录C-this词法" class="headerlink" title="附录C - this词法"></a>附录C - this词法</h2><p>this、匿名函数、bind()</p>
<h2 id="补充：预解析"><a href="#补充：预解析" class="headerlink" title="补充：预解析"></a>补充：预解析</h2><p>在ES6之前，使用var声明会存在变量的预解析，函数也有预解析。这里介绍一下预解析的机制。</p>
<p>什么是预解析：在当前作用域中，在JS代码执行前，浏览器会把搜索var和function声明的变量提前进行声明或定义。</p>
<ul>
<li><p>声明和定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">24</span></span><br></pre></td></tr></table></figure>
<p>先声明: var num, 然后再定义: num = 12。</p>
</li>
<li><p>var声明和function声明在预解析的区别<br>var声明的变量在预解析的时候只是提前的声明，function声明的函数在预解析的时候会提前声明并且会同时定义。</p>
</li>
<li><p>全局作用域下带var和不带var的区别<br>  区别一：</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(num1); <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num2); <span class="comment">// ReferenceError: num2 is not defined</span></span><br><span class="line">num2 = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<p>  区别二：<br>  num2 = 12; 相当于给window增加了一个num2的属性名，属性值是12；<br>  var num1 = 12; 相当于给全局作用域增加了一个全局变量num1，但是不仅如此，它也相当于给window增加了一个属性名num，属性值是12</p>
</li>
<li><p>预解析中的一些变态机制</p>
<ul>
<li>不管条件是否成立，都要把带var的进行提前的声明</li>
<li>只预解析“=”左边的，右边的是指针，不参与预解析<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn(); <span class="comment">// -&gt; undefined();  // Uncaught TypeError: fn is not a function</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); -&gt; <span class="string">'ok'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn(); -&gt; <span class="string">'ok'</span></span><br></pre></td></tr></table></figure></li>
<li>return下的代码依然会进行预解析</li>
<li>名字已经声明过了，不需要重新的声明，但是需要重新的赋值<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// Uncaught TypeError: fn is not a function</span></span><br></pre></td></tr></table></figure>
一道经典题目：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn(); <span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// -&gt; 2                                </span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">10</span>; <span class="comment">//  fn = 10 </span></span><br><span class="line">fn(); <span class="comment">// -&gt; 10()  Uncaught TypeError: fn is not a function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">//不执行</span></span><br></pre></td></tr></table></figure>
其实就相当于：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// 2</span></span><br><span class="line">fn(); <span class="comment">// 2</span></span><br><span class="line">fn = <span class="number">10</span>;</span><br><span class="line">fn();</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>你不知道的JS</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解ES6</title>
    <url>/2020/03/26/JS%E7%9B%B8%E5%85%B3-2020-03-26-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/</url>
    <content><![CDATA[<p>前文：关于ES6的知识记录。</p>
<a id="more"></a> 
<h1 id="第一章-块级绑定"><a href="#第一章-块级绑定" class="headerlink" title="第一章 - 块级绑定"></a>第一章 - 块级绑定</h1><h2 id="var声明与变量提升、块级声明"><a href="#var声明与变量提升、块级声明" class="headerlink" title="var声明与变量提升、块级声明"></a>var声明与变量提升、块级声明</h2><p>var：有变量提升，可重复声明；<br>let：let是块级声明，无变量提升（有暂时性死区），禁止重复声明。<br>const：声明会被认为常量，且需初始化，无变量提升（有暂时性死区），块级声明，禁止重复声明；阻止的是对变量绑定的修改。</p>
<h2 id="循环中的块级绑定"><a href="#循环中的块级绑定" class="headerlink" title="循环中的块级绑定"></a>循环中的块级绑定</h2><p>var    的特点使得循环变量在循环作用域之外仍然可被访问，于是在循环内创建函数就变得很有问题。在此之前通过函数表达式（IIFEs）来解决此问题。但现在可以使用let和const来简化。<br>let是如何解决此问题的：在每次迭代中，都会创建一个新的同名变量并对其进行初始化。</p>
<h2 id="全局块级绑定"><a href="#全局块级绑定" class="headerlink" title="全局块级绑定"></a>全局块级绑定</h2><p>var在全局作用域中声明，创建的是window下的变量，可能无意会覆盖一个原有变量。<br>let可在全局作用域上会创建新的绑定，但不会有任何属性被添加到全局对象上。</p>
<blockquote>
<p>若想让代码能从全局对象中被访问，你仍然需要使用var    。在浏览器中跨越帧或窗口去访问代码时，这种做法非常普遍。</p>
</blockquote>
<h2 id="块级绑定新的最佳实践"><a href="#块级绑定新的最佳实践" class="headerlink" title="块级绑定新的最佳实践"></a>块级绑定新的最佳实践</h2><p>在默认情况下使用const、并且只在知道变量值需要被更改的情况下才使用let    。</p>
<h1 id="第三章-函数"><a href="#第三章-函数" class="headerlink" title="第三章 函数"></a>第三章 函数</h1><h2 id="带参数默认值的函数"><a href="#带参数默认值的函数" class="headerlink" title="带参数默认值的函数"></a>带参数默认值的函数</h2><p>原先在ES5中的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout, callback</span>) </span>&#123;</span><br><span class="line">    timeout = timeout || <span class="number">2000</span>;</span><br><span class="line">    callback = callback || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//	函数的剩余部分</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有点缺陷：timeout = 0时，timeout会被替换为2000，于是使用typeof来改进：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout, callback</span>) </span>&#123;</span><br><span class="line">    timeout = (<span class="keyword">typeof</span> timeout !== <span class="string">"undefined"</span>) ? timeout : <span class="number">2000</span>;</span><br><span class="line">    callback = (<span class="keyword">typeof</span> callback !== <span class="string">"undefined"</span>) ? callback : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//	函数的剩余部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout = <span class="number">2000</span>, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//	函数的剩余部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps:为什么之前JS不这么设计呢？在其它语言这样的写法十分平常。</p>
<p>在使用    ES6    参数默认值的函数中，    arguments    对象的表现总是会与    ES5    的严格模式一致，无论此时函数是否明确运行在严格模式下。参数默认值的存在触发了    arguments    对象与具名参数的分离。</p>
<p>函数参数拥有各自的作用域和暂时性死区，与函数体的作用域相分离，这意味着参数的默认值不允许访问在函数体内部声明的任意变量。</p>
<h2 id="使用不具名参数"><a href="#使用不具名参数" class="headerlink" title="使用不具名参数"></a>使用不具名参数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//	从第二个参数开始处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        result[<span class="built_in">arguments</span>[i]] = object[<span class="built_in">arguments</span>[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">    title: <span class="string">"Understanding	ES6"</span>,</span><br><span class="line">    author: <span class="string">"Nicholas	C.	Zakas"</span>,</span><br><span class="line">    year: <span class="number">2015</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bookData = pick(book, <span class="string">"author"</span>, <span class="string">"year"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bookData.author); <span class="comment">//	"Nicholas	C.	Zakas"</span></span><br><span class="line"><span class="built_in">console</span>.log(bookData.year); <span class="comment">//	2015</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object, ...keys</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++) &#123;</span><br><span class="line">        result[keys[i]] = object[keys[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩余参数的限制条件:剩余参数受到两点限制。一是函数只能有一个剩余参数，并且它必须被放在最后。剩余参数不能在对象字面量的setter属性中使用</p>
<style> 
table th:first-of-type { width: 50%; } 
</style>

<table>
<thead>
<tr>
<th>ES5</th>
<th>ES6</th>
</tr>
</thead>
<tbody><tr>
<td>完全看不出该函数能够处理多个参数;必须从arguments对象索引位置1开始处理而不是从位置0</td>
<td>引入剩余参数</td>
</tr>
<tr>
<td>无</td>
<td>函数构造器的增强能力</td>
</tr>
<tr>
<td>Math.max.apply()</td>
<td>扩展运算符…</td>
</tr>
<tr>
<td>无</td>
<td>每个函数都有name属性</td>
</tr>
<tr>
<td></td>
<td>new.target元属性</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200326103640.png" alt=""></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS事件循环机制</title>
    <url>/2020/03/25/JS%E7%9B%B8%E5%85%B3-3-25-JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>主要内容：</p>
<ul>
<li>介绍单线程</li>
<li>事件循环机制</li>
</ul>
<h3 id="什么是单线程"><a href="#什么是单线程" class="headerlink" title="什么是单线程"></a>什么是单线程</h3><p>JS的单线程指的是<strong>解释和执行JS代码的线程</strong>只有一个，我们把这个称为<strong>主线程</strong>。那除了主线程以外，其实还有其它线程：处理AJAX请求的线程、处理DOM事件的线程、定时器的线程还有读写文件的线程等等，我们把这些单线程称作工作线程。（清楚地理解单线程的概念，异步就好理解了）</p>
<h3 id="异步过程"><a href="#异步过程" class="headerlink" title="异步过程"></a>异步过程</h3><p>异步通常是如何工作的呢？可以这么说，主线程像是一位军师，将不同的任务发送给不同的工作线程，主线程可以继续处理自己的事情。工作线程完成任务后，向主线程报告。主线程收到报告，处理相应的事务。换句话说，主线程和其它工作线程不是捆在一条绳子上的，而是分别独立地工作。<br>从主线程角度来看，一个异步过程主要包含两个要素：</p>
<ol>
<li>发起函数（注册函数）；</li>
<li>回调函数callback；</li>
</ol>
<p>比如说setTimeout(funcxx,1000)代表的意思是至少1秒后开始执行funcxx。其中setTimeout函数就是一个发起函数，1秒后需要执行的funcxx就是一个回调函数。</p>
<p>DOM中的点击事件btn.onclick(funcxx)代表点击按钮元素btn之后执行funcxx，其中onclick就是注册函数，funcxx就是回调函数。</p>
<h3 id="消息队列和事件循环"><a href="#消息队列和事件循环" class="headerlink" title="消息队列和事件循环"></a>消息队列和事件循环</h3><p>那么工作线程完成了异步操作以后，是如何与主线程交互信息的呢？这里就引入了消息队列和事件循环的机制：工作线程<strong>接收到响应结果后</strong>，就将消息放到消息队列，然后主线程通过事件循环来获取消息。而且主线程只有执行完当前的消息才会去取下一消息。（那会不会存在消息的阻塞呢，后面的 “理解JS代码的执行”会给出答案）<br>打个比方：就是各个用户写完信，将信件放进邮箱（消息队列）里，快递员每天（事件循环）都来取这些信件。“队列”的意思就是这些信件是讲究先来后到的，先放进去的信件优先被快递员拿走。（先来先服务）（操作系统中的FIFO）</p>
<p>那消息队列里放的消息具体是什么东西呢？可以简单的理解为：<br>消息就是注册异步任务时的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消息队列中的消息就长这个样子</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callbackFn(response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其中的callbackFn就是前面代码中得到成功响应时的回调函数。</span></span><br></pre></td></tr></table></figure>
<p>注册函数完成后将响应封装成一个JS对象，然后构造一条消息，放到消息队列中等着主线程来执行。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200325102827.png" alt="事件循环机制"></p>
<h3 id="异步和事件"><a href="#异步和事件" class="headerlink" title="异步和事件"></a>异步和事件</h3><p>事件循环中的循环我们已经知道了，那什么是事件呢？</p>
<blockquote>
<p>其实消息队列中的每条消息就是对应着一个事件。<br>那消息对应着事件，为什么要需要取个名称叫事件呢？有的人说为了编程接口对开发者更友好。</p>
</blockquote>
<h3 id="理解-JS-代码的执行（可先跳过）"><a href="#理解-JS-代码的执行（可先跳过）" class="headerlink" title="理解 JS 代码的执行（可先跳过）"></a>理解 JS 代码的执行（可先跳过）</h3><p>现在我们还需要弄明白消息被放到消息队列中以后，消息队列是按照什么样的顺序执行消息的。<br>以setTimeout为例，我们来看一组代码的执行情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> start=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">5000</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'耗时操作'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> end=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'阻塞耗时：'</span>+<span class="built_in">Number</span>(end-start)+<span class="string">'毫秒'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Time1</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出是 (5000)耗时操作, 阻塞耗时：364毫秒, 2, 3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Time2</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> start=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">5000</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'耗时操作'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> end=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'阻塞耗时：'</span>+<span class="built_in">Number</span>(end-start)+<span class="string">'毫秒'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Time1</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出是 (5000)耗时操作, 阻塞耗时：348毫秒, 3, 2</span></span><br></pre></td></tr></table></figure>

<p>根据上面的运行情况，我们可以得出结论：如果主进程的阻塞时间超过两setTimeout执行的间隔时间(400-300ms)，那么先加入队列的先执行。</p>
<p>以上讲的比较简单，接下来系统地讲一下。</p>
<p>在JS的事件循环之中，使用到了三种数据对象：栈、堆、队列。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200325215624.png" alt="并发模型与事件循环"><br><strong>栈</strong>：执行上下文栈，当有函数被调用时，便会创建相应的执行上下文存入栈中；<br><strong>堆</strong>：对象被分配在堆中，表示一大块非结构化的内存区域的计算机术语；<br><strong>队列</strong>：消息队列（任务队列）。每条消息关联着处理这条消息的回调函数。</p>
<p>解释：<br><strong>执行上下文栈</strong></p>
<blockquote>
<p>在 JavaScript 代码运行过程中，会进入到不同的执行环境中，一开始执行时最先进入到全局环境，此时全局上下文首先被创建并入栈，之后当调用函数时则进入相应的函数环境，此时相应函数上下文被创建并入栈，当处于栈顶的执行上下文代码执行完毕后，则会将其出栈。这里的栈便是执行上下文栈。</p>
</blockquote>
<p><strong>任务队列</strong></p>
<blockquote>
<p>在JS事件循环中，存在宏任务（macro-task）和微任务（micor-task）。</p>
</blockquote>
<p>引用一段比喻来帮助理解：</p>
<blockquote>
<p>银行&amp;客户场景：每一个来办理业务的人就可以认为是银行柜员的一个宏任务来存在的，当柜员处理完当前客户的问题以后，选择接待下一位，广播报号，也就是下一个宏任务的开始。而且一个宏任务在执行的过程中，是可以添加一些微任务的，就像在柜台办理业务，你前边的一位老大爷可能在存款，在存款这个业务办理完以后，柜员会问老大爷还有没有其他需要办理的业务，这时老大爷想了一下：“最近P2P爆雷有点儿多，是不是要选择稳一些的理财呢”，然后告诉柜员说，要办一些理财的业务，这时候柜员肯定不能告诉老大爷说：“您再上后边取个号去，重新排队”。无论是什么需求，只要是柜员能够帮她办理的，都会在处理你的业务之前来做这些事情，这些都可以认为是微任务。<br>这就说明：<del>你大爷永远是你大爷</del><br>微任务会比宏任务小，当前的微任务若没执行完是不会执行下一宏任务的。</p>
</blockquote>
<p>针对浏览器的两种任务：</p>
<ul>
<li>宏任务包括：setTimeout、setInterval、I/O、UI rendering</li>
<li>微任务包括：Promise.then、catch finally、Object.observe（已废弃）、MutationObserver（html5新特性）</li>
</ul>
<h3 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event-Loop）"></a>事件循环（Event-Loop）</h3><p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200325223732.png" alt=""><br>同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入 Event Queue 。主线程内的任务执行完毕为空，会去 Event Queue 读取对应的任务，推入主线程执行。 上述过程的不断重复就是我们说的 Event Loop (事件循环)。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200325223844.png" alt="事件循环流程"><br>形象一点的比喻就是：</p>
<blockquote>
<p>每办理完一个业务，柜员就会问当前的客户，是否还有其他需要办理的业务。（检查还有没有微任务需要处理）<br>而客户明确告知说没有事情以后，柜员就去查看后边还有没有等着办理业务的人。（结束本次宏任务、检查还有没有宏任务需要处理）</p>
</blockquote>
<p>脑子在处理事件循环时，得有下面这张图：<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200325232526.png" alt=""></p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.cnblogs.com/jiasm/p/9482443.html" target="_blank" rel="noopener">微任务、宏任务与Event-Loop</a></li>
<li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/#level-1-bossfight" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules</a></li>
<li><a href="https://www.cnblogs.com/yugege/p/9598265.html" target="_blank" rel="noopener">深入理解JavaScript事件循环机制</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>第十三章 - 事件</title>
    <url>/2020/03/24/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB-JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-24-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>本章内容 </p>
<ul>
<li>理解事件流 </li>
<li>使用事件处理程序 </li>
<li>不同的事件类型 </li>
</ul>
<p>JS与HTML之间的交互是通过<strong>事件</strong>实现的。可以使用<strong>侦听器</strong>（或处理程序）来预订事件，以便事件发生时执行相应的代码。</p>
<h2 id="13-1-事件流"><a href="#13-1-事件流" class="headerlink" title="13.1 事件流"></a>13.1 事件流</h2><p>事件流描述的是从页面中接收事件的顺序。IE 的事件流是<strong>事件冒泡流</strong>，而 Netscape Communicator 的事件流是<strong>事件捕获流</strong>。 </p>
<h3 id="13-1-1-事件冒泡"><a href="#13-1-1-事件冒泡" class="headerlink" title="13.1.1 事件冒泡"></a>13.1.1 事件冒泡</h3><p>IE 的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次<strong>最深</strong>的那个节点）接收，然后<strong>逐级向上</strong>传播到较为不具体的节点（文档）。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200324231748.png" alt="事件冒泡"></p>
<h3 id="13-1-2-事件捕获（很少用）"><a href="#13-1-2-事件捕获（很少用）" class="headerlink" title="13.1.2 事件捕获（很少用）"></a>13.1.2 事件捕获（很少用）</h3><p>事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200324231807.png" alt="事件捕获"></p>
<h3 id="13-1-3-DOM事件流"><a href="#13-1-3-DOM事件流" class="headerlink" title="13.1.3 DOM事件流"></a>13.1.3 DOM事件流</h3><p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200324232110.png" alt=""><br>在 DOM 事件流中，实际的目标（<div>元素）在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从 document 到<html>再到<body>后就停止了。下一个阶段是“处于目标”阶段，于是事件在<div>上发生，并在事件处理（后面将会讨论这个概念）中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。</p>
<h2 id="13-2-事件处理程序"><a href="#13-2-事件处理程序" class="headerlink" title="13.2 事件处理程序"></a>13.2 事件处理程序</h2><p>事件就是用户或浏览器自身执行的<strong>某种动作</strong>。诸如 click、load 和 mouseover，都是事件的名字。而响应某个事件的函数就叫做<strong>事件处理程序</strong>（或<strong>事件侦听器</strong>）。</p>
<h3 id="13-2-1-HTML事件处理程序"><a href="#13-2-1-HTML事件处理程序" class="headerlink" title="13.2.1 HTML事件处理程序"></a>13.2.1 HTML事件处理程序</h3><h3 id="13-2-2-DOM0-级事件处理程序"><a href="#13-2-2-DOM0-级事件处理程序" class="headerlink" title="13.2.2 DOM0 级事件处理程序"></a>13.2.2 DOM0 级事件处理程序</h3><p>通过 JavaScript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。<br>使用 DOM0 级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素的作用域中运行；换句话说，程序中的 this 引用当前元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>); </span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="keyword">this</span>.id);    <span class="comment">//"myBtn" </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="13-2-3-DOM2-级事件处理程序"><a href="#13-2-3-DOM2-级事件处理程序" class="headerlink" title="13.2.3 DOM2 级事件处理程序"></a>13.2.3 DOM2 级事件处理程序</h3><p>DOM2 级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：<strong>addEventListener()</strong>和 <strong>removeEventListener()</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>); </span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="keyword">this</span>.id); </span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>使用 DOM2 级方法添加事件处理程序的主要好处是可以添加多个事件处理程序，处理程序会按照添加它们的顺序触发。<br>通过 addEventListener()添加的事件处理程序只能使用 removeEventListener()来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过 addEventListener()添加的匿名函数将无法移除。</p>
<h3 id="13-2-4-IE事件处理程序"><a href="#13-2-4-IE事件处理程序" class="headerlink" title="13.2.4 IE事件处理程序"></a>13.2.4 IE事件处理程序</h3><p>IE 实现了与 DOM 中类似的两个方法：<strong>attachEvent()</strong>和 <strong>detachEvent()</strong>。通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段。 要使用 attachEvent()为按钮添加一个事件处理程序，可以使用以下代码。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>); </span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="string">"Clicked"</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 IE 中使用 attachEvent()与使用 DOM0 级方法的主要区别在于事件处理程序的作用域。在使用 DOM0 级方法的情况下，事件处理程序会在其所属元素的作用域内运行；在使用 attachEvent()方法的情况下，事件处理程序会在<strong>全局作用域中</strong>运行，因此 this 等于 window。<br>使用 attachEvent()添加的事件可以通过 detachEvent()来移除，条件是必须提供相同的参数。<br>比较表格如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>DOM0 级事件处理程序</th>
<th>DOM2 级事件处理程序</th>
<th>IE事件处理程序</th>
</tr>
</thead>
<tbody><tr>
<td>添加事件处理程序</td>
<td>只能添加一个同一事件；事件处理程序在元素的作用域内运行</td>
<td>可添加多个；可设置在捕获阶段还是冒泡阶段</td>
<td>IE的；可添加多个；在全局作用域内；冒泡阶段</td>
</tr>
</tbody></table>
<h3 id="13-2-5-跨浏览器的事件处理程序"><a href="#13-2-5-跨浏览器的事件处理程序" class="headerlink" title="13.2.5 跨浏览器的事件处理程序"></a>13.2.5 跨浏览器的事件处理程序</h3><p>要保证处理事件的代码能在大多数浏览器下一致地运行，只需关注冒泡阶段。<br>第一个要创建的方法是 addHandler()，它的职责是视情况分别使用 DOM0 级方法、DOM2 级方法或 IE 方法来添加事件。这个方法属于一个名叫 EventUtil 的对象。<br>addHandler()方法接受 3 个参数：要操作的元素、事件名称和事件处理程序函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123; </span><br><span class="line">  </span><br><span class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (element.addEventListener)&#123; </span><br><span class="line">            element.addEventListener(type, handler, <span class="literal">false</span>); </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent)&#123; </span><br><span class="line">            element.attachEvent(<span class="string">"on"</span> + type, handler); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            element[<span class="string">"on"</span> + type] = handler; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, </span><br><span class="line">    removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (element.removeEventListener)&#123; </span><br><span class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>); </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent)&#123; </span><br><span class="line">            element.detachEvent(<span class="string">"on"</span> + type, handler); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            element[<span class="string">"on"</span> + type] = <span class="literal">null</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="13-3-事件对象"><a href="#13-3-事件对象" class="headerlink" title="13.3 事件对象"></a>13.3 事件对象</h2><p>在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的信息。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200324235253.png" alt=""><br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200324235308.png" alt=""><br>在需要通过一个函数处理多个事件时，可以使用 type 属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>); </span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">switch</span>(event.type)&#123; </span><br><span class="line">        <span class="keyword">case</span> <span class="string">"click"</span>: </span><br><span class="line">            alert(<span class="string">"Clicked"</span>); </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">             </span><br><span class="line">        <span class="keyword">case</span> <span class="string">"mouseover"</span>: </span><br><span class="line">            event.target.style.backgroundColor = <span class="string">"red"</span>; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">             </span><br><span class="line">        <span class="keyword">case</span> <span class="string">"mouseout"</span>: </span><br><span class="line">            event.target.style.backgroundColor = <span class="string">""</span>; </span><br><span class="line">            <span class="keyword">break</span>;                         </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">btn.onclick = handler; </span><br><span class="line">btn.onmouseover = handler; </span><br><span class="line">btn.onmouseout = handler;</span><br></pre></td></tr></table></figure>
<p>要阻止特定事件的默认行为，可以使用 preventDefault()方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">"myLink"</span>); </span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123; </span><br><span class="line">    event.preventDefault(); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>stopPropagation()方法用于立即停止事件在 DOM 层次中的传播，即取消进一步的事件捕获或冒泡。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>); </span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123; </span><br><span class="line">    alert(<span class="string">"Clicked"</span>); </span><br><span class="line">    event.stopPropagation(); </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123; </span><br><span class="line">    alert(<span class="string">"Body clicked"</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>事件对象的 eventPhase 属性，可以用来确定事件当前正位于事件流的哪个阶段。捕获阶段1，目标对象2，冒泡阶段3。</p>
<h3 id="13-3-2-IE中的事件对象"><a href="#13-3-2-IE中的事件对象" class="headerlink" title="13.3.2 IE中的事件对象"></a>13.3.2 IE中的事件对象</h3><p>略。</p>
<h3 id="13-3-3-跨浏览器的事件对象"><a href="#13-3-3-跨浏览器的事件对象" class="headerlink" title="13.3.3 跨浏览器的事件对象"></a>13.3.3 跨浏览器的事件对象</h3><p>略。</p>
<h2 id="13-4-事件类型"><a href="#13-4-事件类型" class="headerlink" title="13.4 事件类型"></a>13.4 事件类型</h2><p>“DOM3级事件”规定了以下几类事件。 </p>
<ul>
<li>UI（User Interface，用户界面）事件，当用户与页面上的元素交互时触发； </li>
<li>焦点事件，当元素获得或失去焦点时触发； </li>
<li>鼠标事件，当用户通过鼠标在页面上执行操作时触发； </li>
<li>滚轮事件，当使用鼠标滚轮（或类似设备）时触发； </li>
<li>文本事件，当在文档中输入文本时触发； </li>
<li>键盘事件，当用户通过键盘在页面上执行操作时触发； </li>
<li>合成事件，当为 IME（Input Method Editor，输入法编辑器）输入字符时触发； </li>
<li>变动（mutation）事件，当底层 DOM 结构发生变化时触发。 </li>
</ul>
<p>略。</p>
<h2 id="13-5-内存和性能"><a href="#13-5-内存和性能" class="headerlink" title="13.5 内存和性能"></a>13.5 内存和性能</h2><p>在 JavaScript 中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>第十章 - DOM</title>
    <url>/2020/03/23/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB-JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-23-%E7%AC%AC%E5%8D%81%E7%AB%A0-DOM/</url>
    <content><![CDATA[<p>本章内容 </p>
<ul>
<li>理解包含不同层次节点的 DOM </li>
<li>使用不同的节点类型 </li>
<li>克服浏览器兼容性问题及各种陷阱 </li>
</ul>
<p>DOM（文档对象模型）是针对 HTML 和 XML 文档的一个 API（应用程序编程接口）。DOM 描绘了一个<strong>层次化的节点树</strong>，允许开发人员添加、移除和修改页面的某一部分。</p>
<h2 id="10-1-节点层次"><a href="#10-1-节点层次" class="headerlink" title="10.1 节点层次"></a>10.1 节点层次</h2><p>在 HTML 页面中，<strong>文档元素</strong>始终都是<html>元素。在 XML 中，没有预定义的元素，因此任何元素都可能成为文档元素。<br>HTML 文档表示为一个层次结构：<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200323212317.png" alt="DOM树"></p>
<h3 id="10-1-1-Node类型"><a href="#10-1-1-Node类型" class="headerlink" title="10.1.1 Node类型"></a>10.1.1 Node类型</h3><p>DOM1 级定义了一个 Node 接口，该接口将由 DOM 中的所有节点类型实现。每个节点都有一个 <strong>nodeType</strong> 属性，用于表明节点的类型。节点类型由在 Node 类型中定义的下列12 个数值常量来表示，任何节点类型必居其一： </p>
<ul>
<li>Node.ELEMENT_NODE(1)； </li>
<li>Node.ATTRIBUTE_NODE(2)； </li>
<li>Node.TEXT_NODE(3)； </li>
<li>Node.CDATA_SECTION_NODE(4)； </li>
<li>Node.ENTITY_REFERENCE_NODE(5)； </li>
<li>Node.ENTITY_NODE(6)； </li>
<li>Node.PROCESSING_INSTRUCTION_NODE(7)； </li>
<li>Node.COMMENT_NODE(8)；</li>
<li>Node.DOCUMENT_NODE(9)； </li>
<li>Node.DOCUMENT_TYPE_NODE(10)； </li>
<li>Node.DOCUMENT_FRAGMENT_NODE(11)； </li>
<li>Node.NOTATION_NODE(12)。</li>
</ul>
<ol>
<li>nodeName 和 nodeValue 属性<br>要了解节点的具体信息，可以使用 <strong>nodeName</strong> 和 <strong>nodeValue</strong> 这两个属性。这两个属性的值完全取决于节点的类型。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>)&#123; </span><br><span class="line"> value = someNode.nodeName; <span class="comment">//nodeName 的值是元素的标签名 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>节点关系<br>文档中所有的节点之间都存在这样或那样的关系。每个节点都有一个 <strong>childNodes</strong> 属性，其中保存着一个 NodeList 对象。NodeList 是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。如何访问保存在 NodeList 中的节点——可以通过方括号，也可以使用 item()方法。 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstChild = someNode.childNodes[<span class="number">0</span>]; </span><br><span class="line"><span class="keyword">var</span> secondChild = someNode.childNodes.item(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">var</span> count = someNode.childNodes.length;</span><br></pre></td></tr></table></figure>
通过使用列表中每个节点的 <strong>previousSibling</strong>和 <strong>nextSibling</strong> 属性，可以访问同一列表中的其他节点。<br>父节点的 <strong>firstChild</strong> 和 <strong>lastChild</strong> 属性分别指向其 childNodes 列表中的第一个和最后一个节点。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200323214352.png" alt="节点各个关系"><br>另外，<strong>hasChildNodes()</strong>也是一个非常有用的方法，这个方法在节点包含一或多个子节点的情况下返回 true；<br>所有节点都有的最后一个属性是 <strong>ownerDocument</strong>，该属性指向表示整个文档的文档节点document。</li>
<li>操作节点<br>因为关系指针都是只读的，所以 DOM 提供了一些操作节点的方法。<ul>
<li>appendChild()：用于向 childNodes 列表的末尾添加一个节点。更新完成后，appendChild()返回新增的节点。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> returnedNode = someNode.appendChild(newNode); </span><br><span class="line">alert(returnedNode == newNode);         <span class="comment">//true </span></span><br><span class="line">alert(someNode.lastChild == newNode);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li>insertBefore()：把节点放在 childNodes 列表中某个特定的位置上。这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点（previousSibling），同时被方法返回。</li>
<li>replaceChild()：替换节点。要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。</li>
<li>removeChild()：移除节点。接受一个参数即要移除的节点，然后返回被移除的节点。<br>四个方法操作的都是某个节点的子节点，所以必须先取得父节点（使用 parentNode 属性）。</li>
</ul>
</li>
<li>其他方法<br>有两个方法是所有类型的节点都有的。<ul>
<li>cloneNode()：用于创建调用这个方法的节点的一个完全相同的副本。cloneNode()方法接受一个布尔值参数，表示是否执行深复制。执行<strong>深复制</strong>，也就是复制节点及其整个子节点树；在参数为 false 的情况下，执行浅复制，即只复制节点本身（孤儿）。</li>
<li>normalize()：处理文档树中的文本节点。</li>
</ul>
</li>
</ol>
<h3 id="10-1-2-Document类型"><a href="#10-1-2-Document类型" class="headerlink" title="10.1.2 Document类型"></a>10.1.2 Document类型</h3><p>在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML 页面。document 对象是 window 对象的一个属性，因此可以将其作为全局对象来访问。Document 节点具有下列特征：</p>
<ul>
<li>nodeType 的值为 9； </li>
<li>nodeName 的值为”#document”； </li>
<li>nodeValue 的值为 null； </li>
<li>parentNode 的值为 null； </li>
<li>ownerDocument 的值为 null； </li>
<li>其子节点可能是一个 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction或 Comment。</li>
</ul>
<ol>
<li>文档的子节点<br>documentElement属性，该属性始终指向 HTML 页面中的<html>元素。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="built_in">document</span>.documentElement; <span class="comment">//取得对&lt;html&gt;的引用 </span></span><br><span class="line">alert(html === <span class="built_in">document</span>.childNodes[<span class="number">0</span>]);     <span class="comment">//true </span></span><br><span class="line">alert(html === <span class="built_in">document</span>.firstChild); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
body 属性，直接指向&lt;body&gt;元素，document.body 在 JavaScript 代码中出现的频率非常高。<br>document.doctype来访问&lt;!DOCTYPE&gt;标签，但各个浏览器的支持不一致：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doctype = <span class="built_in">document</span>.doctype;     <span class="comment">//取得对&lt;!DOCTYPE&gt;的引用</span></span><br></pre></td></tr></table></figure></li>
<li>文档信息<br>document 对象还有一些标准的 Document 对象所没有的属性。<br>document.title包含着&lt;title&gt;元素中的文本，修改 title 属性的值不会改变&lt;title&gt;元素。<br>对网页的请求有关的三个属性：URL、domain 和 referrer。</li>
</ol>
<p><strong>URL</strong> 属性：包含页面完整的 URL（即地址栏中显示的 URL）；<br><strong>domain</strong> 属性：只包含页面的域名；<br><strong>referrer</strong> 属性：保存着链接到当前页面的那个页面的 URL。<br>在这 3 个属性中，只有 domain 是可以设置的。能将这个属性设置为 URL 中不包含的域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设页面来自 p2p.wrox.com 域 </span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">"wrox.com"</span>; <span class="comment">// 成功 </span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">"nczonline.net"</span>;      <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure>
<p>可以通过设置相同的document.domain来解决不同子域的页面的相互访问。浏览器对 domain 属性还有一个限制，即如果域名一开始是“松散的”（loose），那么不能将它再设置为“紧绷的”（tight）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设页面来自于 p2p.wrox.com 域 </span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">"wrox.com"</span>;         <span class="comment">//松散的（成功） </span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">"p2p.wrox.com"</span>;     <span class="comment">//紧绷的（出错！）</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查找元素<br>getElementById()和 getElementsByTagName()。<br>第一个方法，getElementById()，接收一个参数：要取得的<em>元素的 ID</em>。<br>另一个常用于取得元素引用的方法是 getElementsByTagName()。这个方法接受一个参数，即要取得<em>元素的标签名</em>，而返回的是包含零或多个元素的 NodeList。在 HTML 文档中，这个方法会返回一个 HTMLCollection 对象，作为一个“动态”集合，该对象与NodeList 非常类似。<br>namedItem()使用这个方法可以通过元素的 name 特性取得集合中的项。<br>HTMLCollection 还支持按名称访问项，对命名的项也可以使用方括号语法来访问：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myImage = images[<span class="string">"myImage"</span>];</span><br></pre></td></tr></table></figure>
要想取得文档中的<strong>所有元素</strong>，可以向 getElementsByTagName()中传入”*”。<br>getElementsByName()：这个方法会返回带有给定 name 特性的所有元素。最常使用 getElementsByName()方法的情况是取得单选按钮：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;fieldset&gt; </span><br><span class="line">    &lt;legend&gt;Which color <span class="keyword">do</span> you prefer?&lt;<span class="regexp">/legend&gt; </span></span><br><span class="line"><span class="regexp">    &lt;ul&gt; </span></span><br><span class="line"><span class="regexp">        &lt;li&gt;&lt;input type="radio" value="red" name="color" id="colorRed"&gt; </span></span><br><span class="line"><span class="regexp">            &lt;label for="colorRed"&gt;Red&lt;/</span>label&gt;&lt;<span class="regexp">/li&gt; </span></span><br><span class="line"><span class="regexp">        &lt;li&gt;&lt;input type="radio" value="green" name="color" id="colorGreen"&gt; </span></span><br><span class="line"><span class="regexp">            &lt;label for="colorGreen"&gt;Green&lt;/</span>label&gt;&lt;<span class="regexp">/li&gt; </span></span><br><span class="line"><span class="regexp">        &lt;li&gt;&lt;input type="radio" value="blue" name="color" id="colorBlue"&gt; </span></span><br><span class="line"><span class="regexp">            &lt;label for="colorBlue"&gt;Blue&lt;/</span>label&gt;&lt;<span class="regexp">/li&gt; </span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt; </span><br><span class="line">&lt;<span class="regexp">/fieldset&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>特殊集合<br>略。</li>
<li>DOM 一致性检测略。</li>
<li>文档写入<br>write()、writeln()、open()和 close()。</li>
</ol>
<p><strong>write()</strong>和 <strong>writeln()</strong>方法都接受一个字符串参数，即要写入到输出流中的文本。write()会原样写入，而 writeln()则会在字符串的末尾添加一个换行符（\n）。在页面被加载的过程中，可以使用这两个方法向页面中动态地加入内容。此外，还可以使用 write()和 writeln()方法动态地包含外部资源，例如 JavaScript 文件等。如果在文档加载结束后再调用 document.write()，那么输出的内容将会重写整个页面。<br>方法 <strong>open()</strong>和 <strong>close()</strong>分别用于打开和关闭网页的输出流。</p>
<h3 id="10-1-3-Element类型"><a href="#10-1-3-Element类型" class="headerlink" title="10.1.3 Element类型"></a>10.1.3 Element类型</h3><p>除了 Document 类型之外，Element 类型就要算是 Web 编程中最常用的类型了。Element 类型用于表现 XML 或 HTML 元素，提供了对<strong>元素标签名、子节点及特性</strong>的访问。Element 节点具有以下特征： </p>
<ul>
<li>nodeType 的值为 1； </li>
<li>nodeName 的值为元素的标签名； </li>
<li>nodeValue 的值为 null； </li>
<li>parentNode 可能是 Document 或 Element； </li>
<li>其子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或EntityReference。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (element.tagName == <span class="string">"div"</span>)&#123; <span class="comment">//不能这样比较，很容易出错！ </span></span><br><span class="line">    <span class="comment">//在此执行某些操作 </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (element.tagName.toLowerCase() == <span class="string">"div"</span>)&#123; <span class="comment">//这样最好（适用于任何文档） </span></span><br><span class="line">    <span class="comment">//在此执行某些操作 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>HTML 元素<br>所有 HTML 元素都由 HTMLElement 类型表示，不是直接通过这个类型，也是通过它的子类型来表示。添加的这些属性分别对应于每个 HTML元素中都存在的下列标准特性。 </li>
</ol>
<ul>
<li>id，元素在文档中的唯一标识符。 </li>
<li>title，有关元素的附加说明信息，一般通过工具提示条显示出来。 </li>
<li>lang，元素内容的语言代码，很少使用。 </li>
<li>dir，语言的方向，值为”ltr”（left-to-right，从左至右）或”rtl”（right-to-left，从右至左），也很少使用。 </li>
<li>className，与元素的 class特性对应，即为元素指定的 CSS 类。<br>元素中指定的所有信息，都可以通过下列 JavaScript 代码取得：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>); </span><br><span class="line">alert(div.id); <span class="comment">//"myDiv"" </span></span><br><span class="line">alert(div.className); <span class="comment">//"bd" </span></span><br><span class="line">alert(div.title); <span class="comment">//"Body text" </span></span><br><span class="line">alert(div.lang); <span class="comment">//"en" </span></span><br><span class="line">alert(div.dir); <span class="comment">//"ltr"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li><p>取得特性<br>getAttribute()、setAttribute()和 removeAttribute()。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>); </span><br><span class="line">alert(div.getAttribute(<span class="string">"id"</span>));         <span class="comment">//"myDiv" </span></span><br><span class="line">alert(div.getAttribute(<span class="string">"class"</span>));      <span class="comment">//"bd" </span></span><br><span class="line">alert(div.getAttribute(<span class="string">"title"</span>));      <span class="comment">//"Body text" </span></span><br><span class="line">alert(div.getAttribute(<span class="string">"lang"</span>));       <span class="comment">//"en" </span></span><br><span class="line">alert(div.getAttribute(<span class="string">"dir"</span>));        <span class="comment">//"ltr"</span></span><br></pre></td></tr></table></figure>
<p>有两类特殊的特性，属性的值与通过 getAttribute()返回的值并不相同。<br>第一类特性就是 style，用于通过 CSS 为元素指定样式。在通过 getAttribute()访问时，返回的 style 特性值中包含的是 CSS 文本，而通过属性来访问它则会返回一个对象。<br>第二类与众不同的特性是 onclick 这样的事件处理程序。onclick 特性中包含的是 JavaScript 代码，如果通过 getAttribute()访问，则会返回相应代码的字符串。而在访问onclick 属性时，则会返回一个 JavaScript 函数。</p>
</li>
<li><p>设置特性<br>setAttribute()，这个方法接受两个参数：要设置的特性名和值。<br>通过 setAttribute()方法既可以操作 HTML 特性也可以操作自定义特性。通过这个方法设置的特性名会被统一转换为小写形式，即”ID”最终会变成”id”。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.setAttribute(<span class="string">"id"</span>, <span class="string">"someOtherId"</span>); </span><br><span class="line">div.setAttribute(<span class="string">"class"</span>, <span class="string">"ft"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>发现这样看红宝书效率不高，暂停，略。</p>
<h2 id="10-3-小结"><a href="#10-3-小结" class="headerlink" title="10.3 小结"></a>10.3 小结</h2><p>DOM 是语言中立的 API，用于访问和操作 HTML 和 XML 文档。DOM1 级将 HTML 和 XML 文档形象地看作一个层次化的节点树，可以使用 JavaScript 来操作这个节点树，进而改变底层文档的外观和结构。<br>DOM 由各种节点构成，简要总结如下。 </p>
<ul>
<li>最基本的节点类型是 Node，用于抽象地表示文档中一个独立的部分；所有其他类型都继承自Node。 </li>
<li>Document 类型表示整个文档，是一组分层节点的根节点。在 JavaScript 中，document 对象是Document 的一个实例。使用 document 对象，有很多种方式可以查询和取得节点。 </li>
<li>Element 节点表示文档中的所有 HTML 或 XML 元素，可以用来操作这些元素的内容和特性。 </li>
<li>另外还有一些节点类型，分别表示文本内容、注释、文档类型、CDATA 区域和文档片段。 </li>
</ul>
<p>NodeList 对象都是“动态的”，这就意味着每次访问NodeList 对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少 DOM 操作。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>第九章 - 客户端检测</title>
    <url>/2020/03/23/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB-JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-23-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p>本章内容 </p>
<ul>
<li>使用能力检测 </li>
<li>用户代理检测的历史 </li>
<li>选择检测方式</li>
</ul>
<p>面对浏览器普遍存在的不一致性问题，开发人员要么采取迁就各方的“最小公分母”策略，要么（也是更常见的）就得利用各种客户端检测方法，来突破或者规避种种局限性。<br>但最重要的还是要知道，不到万不得已，就不要使用客户端检测。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>小结<br>客户端检测是 JavaScript 开发中最具争议的一个话题。由于浏览器间存在差别，通常需要根据不同浏览器的能力分别编写不同的代码。有不少客户端检测方法，但下列是最经常使用的。 </p>
<ul>
<li>能力检测：在编写代码之前先检测特定浏览器的能力。例如，脚本在调用某个函数之前，可能要先检测该函数是否存在。这种检测方法将开发人员从考虑具体的浏览器类型和版本中解放出来，让他们把注意力集中到相应的能力是否存在上。能力检测无法精确地检测特定的浏览器和版本。 </li>
<li>怪癖检测：怪癖实际上是浏览器实现中存在的 bug，例如早期的 WebKit 中就存在一个怪癖，即它会在 for-in 循环中返回被隐藏的属性。怪癖检测通常涉及到运行一小段代码，然后确定浏览器是否存在某个怪癖。由于怪癖检测与能力检测相比效率更低，因此应该只在某个怪癖会干扰脚本运行的情况下使用。怪癖检测无法精确地检测特定的浏览器和版本。 </li>
<li>用户代理检测：通过检测用户代理字符串来识别浏览器。用户代理字符串中包含大量与浏览器有关的信息，包括浏览器、平台、操作系统及浏览器版本。用户代理字符串有过一段相当长的发展历史，在此期间，浏览器提供商试图通过在用户代理字符串中添加一些欺骗性信息，欺骗网站相信自己的浏览器是另外一种浏览器。用户代理检测需要特殊的技巧，特别是要注意 Opera会隐瞒其用户代理字符串的情况。即便如此，通过用户代理字符串仍然能够检测出浏览器所用<br>的呈现引擎以及所在的平台，包括移动设备和游戏系统。 </li>
</ul>
<p>在决定使用哪种客户端检测方法时，一般应优先考虑使用能力检测。怪癖检测是确定应该如何处理代码的第二选择。而用户代理检测则是客户端检测的最后一种方案，因为这种方法对用户代理字符串具有很强的依赖性。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>第八章 - BOM</title>
    <url>/2020/03/23/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB-JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-23-%E7%AC%AC%E5%85%AB%E7%AB%A0-BOM/</url>
    <content><![CDATA[<p>本章内容 </p>
<ul>
<li>理解 window 对象——BOM 的核心 </li>
<li>控制窗口、框架和弹出窗口 </li>
<li>利用 location 对象中的页面信息 </li>
<li>使用 navigator 对象了解浏览器</li>
</ul>
<p>BOM（浏览器对象模型） 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。</p>
<h2 id="8-1-window-对象"><a href="#8-1-window-对象" class="headerlink" title="8.1 window 对象"></a>8.1 window 对象</h2><p>BOM 的核心对象是 window，它表示浏览器的一个实例。</p>
<h3 id="8-1-1-全局作用域"><a href="#8-1-1-全局作用域" class="headerlink" title="8.1.1 全局作用域"></a>8.1.1 全局作用域</h3><p>由于 window 对象同时扮演着 ECMAScript 中 Global 对象的角色，因此所有在全局作用域中声明的变量、函数都会变成 window 对象的属性和方法。<br>定义全局变量与在 window 对象上直接定义属性还是有一点差别：全局变量不能通过 delete 操作符删除，而直接在 window 对象上的定义的属性可以。</p>
<h3 id="8-1-2-窗口关系及框架"><a href="#8-1-2-窗口关系及框架" class="headerlink" title="8.1.2 窗口关系及框架"></a>8.1.2 窗口关系及框架</h3><p>如果页面中包含框架，则每个框架都<strong>拥有自己的 window 对象</strong>，并且保存在 frames集合中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;html&gt; </span><br><span class="line">    &lt;head&gt; </span><br><span class="line">        &lt;title&gt;Frameset Example&lt;<span class="regexp">/title&gt; </span></span><br><span class="line"><span class="regexp">    &lt;/</span>head&gt; </span><br><span class="line">    &lt;frameset rows=<span class="string">"160,*"</span>&gt; </span><br><span class="line">        &lt;frame src=<span class="string">"frame.htm"</span> name=<span class="string">"topFrame"</span>&gt; </span><br><span class="line">        &lt;frameset cols=<span class="string">"50%,50%"</span>&gt; </span><br><span class="line">            &lt;frame src=<span class="string">"anotherframe.htm"</span> name=<span class="string">"leftFrame"</span>&gt; </span><br><span class="line">            &lt;frame src=<span class="string">"yetanotherframe.htm"</span> name=<span class="string">"rightFrame"</span>&gt; </span><br><span class="line">        &lt;<span class="regexp">/frameset&gt; </span></span><br><span class="line"><span class="regexp">    &lt;/</span>frameset&gt; </span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200323124653.png" alt="不同访问方式"></p>
<p>与框架有关的最后一个对象是 self，它始终指向 window；实际上，self 和 window 对象可以互换使用。引入 self 对象的目的只是为了与 top 和 parent 对象对应起来，因此它不格外包含其他值。 </p>
<h3 id="8-1-3-窗口位置"><a href="#8-1-3-窗口位置" class="headerlink" title="8.1.3 窗口位置"></a>8.1.3 窗口位置</h3><p>IE、Safari、Opera 和 Chrome 都提供了screenLeft 和 screenTop 属性，分别用于表示窗口相对于屏幕左边和上边的位置。<br>moveTo()和 moveBy()方法都接收两个参数，moveTo()接收的是新位置的 x 和 y 坐标值，而 moveBy()接收的是在水平和垂直方向上移动的像素数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将窗口移动到屏幕左上角 </span></span><br><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">0</span>,<span class="number">0</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">//将窗向下移动 100 像素 </span></span><br><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">0</span>,<span class="number">100</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">//将窗口移动到(200,300) </span></span><br><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">200</span>,<span class="number">300</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">//将窗口向左移动 50 像素 </span></span><br><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">-50</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>另外，这两个方法都不适用于框架，只能对最外层的 window 对象使用。 </p>
<h3 id="8-1-4-窗口大小"><a href="#8-1-4-窗口大小" class="headerlink" title="8.1.4 窗口大小"></a>8.1.4 窗口大小</h3><p>innerWidth、innerHeight、outerWidth 和 outerHeight。在 Chrome 中，outerWidth、outerHeight 与innerWidth、innerHeight 返回相同的值，即视口（viewport）大小而非浏览器窗口大小。<br>虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小，如下所示。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth, </span><br><span class="line">    pageHeight = <span class="built_in">window</span>.innerHeight; </span><br><span class="line">     </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>)&#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>)&#123; </span><br><span class="line">        pageWidth = <span class="built_in">document</span>.documentElement.clientWidth; </span><br><span class="line">        pageHeight = <span class="built_in">document</span>.documentElement.clientHeight; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        pageWidth = <span class="built_in">document</span>.body.clientWidth; </span><br><span class="line">        pageHeight = <span class="built_in">document</span>.body.clientHeight; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>略。</p>
<h3 id="8-1-5-导航和打开窗口"><a href="#8-1-5-导航和打开窗口" class="headerlink" title="8.1.5 导航和打开窗口"></a>8.1.5 导航和打开窗口</h3><p>使用 <strong>window.open()</strong>方法既可以导航到一个特定的 URL，也可以打开一个新的浏览器窗口。这个方法可以接收 4 个参数：要加载的 URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。<br>如果为 window.open()传递了第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具有该名称的窗口或框架中加载第一个参数指定的 URL。</p>
<ul>
<li><p>弹出窗口<br>如果给 window.open()传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。如果没有传入第三个参数，那么就会打开一个带有全部默认设置（工具栏、地址栏和状态栏等）的新浏览器窗口（或者打开一个新标签页——根据浏览器设置）。在不打开新窗口的情况下，会忽略第三个参数。<br>第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。下表展示了这个字符串的设置选项：<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200323131709.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com/"</span>,<span class="string">"wroxWindow"</span>, </span><br><span class="line">            <span class="string">"height=400,width=400,top=10,left=10,resizable=yes"</span>);</span><br><span class="line"><span class="comment">//调整大小 </span></span><br><span class="line">wroxWin.resizeTo(<span class="number">500</span>,<span class="number">500</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">//移动位置 </span></span><br><span class="line">wroxWin.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 调用 close()方法还可以关闭新打开的窗口。 </span></span><br><span class="line">wroxWin.close();</span><br></pre></td></tr></table></figure>
<p>这行代码会打开一个新的可以调整大小的窗口，窗口初始大小为 400×400 像素，并且距屏幕上沿和左边各 10 像素，然后调整大小、移动位置，关闭窗口。弹出窗口可以调用 top.close()在不经用户允许的情况下关闭自己。<br>新创建的 window 对象有一个 opener 属性，其中保存着打开它的原始窗口对象，但原始窗口中并没有这样的指针指向弹出窗口，只能在必要的时候自己来手动实现跟踪。 </p>
</li>
<li><p>安全限制<br>略</p>
</li>
<li><p>弹出窗口屏蔽程序<br>略</p>
</li>
</ul>
<h3 id="8-1-6-间歇调用和超时调用"><a href="#8-1-6-间歇调用和超时调用" class="headerlink" title="8.1.6 间歇调用和超时调用"></a>8.1.6 间歇调用和超时调用</h3><p><strong>超时调用</strong>：需要使用 window 对象的 <strong>setTimeout()方法</strong>，它接受两个参数：要执行的代码和以毫秒表示的时间（即在执行代码前需要等待多少毫秒）。其中，第一个参数可以是一个包含 JavaScript 代码的字符串（就和在 eval()函数中使用的字符串一样），也可以是一个函数。推荐第二种。<br>第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行。setTimeout()的第二个参数告诉 JavaScript <strong>再过多长时间把当前任务添加到队列中</strong>。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。<br>可以调用clearTimeout()方法并将相应的超时调用 ID 作为参数传递给它，来取消超时调用。</p>
<p><strong>间歇调用setInterval()</strong>：会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。<br>要取消尚未执行的间歇调用，可以使用 clearInterval()方法并传入相应的间歇调用 ID，否则间歇调用会一直执行。以下是一个常见的使用间歇调用的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">var</span> max = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">var</span> intervalId = <span class="literal">null</span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    num++; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//如果执行次数达到了 max 设定的值，则取消后续尚未执行的调用 </span></span><br><span class="line">    <span class="keyword">if</span> (num == max) &#123; </span><br><span class="line">        clearInterval(intervalId); </span><br><span class="line">        alert(<span class="string">"Done"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">intervalId = setInterval(incrementNumber, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<p>在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。</p>
<h3 id="8-1-7-系统对话框"><a href="#8-1-7-系统对话框" class="headerlink" title="8.1.7 系统对话框"></a>8.1.7 系统对话框</h3><p>浏览器通过 alert()、confirm()和 prompt()方法可以调用系统对话框向用户显示消息。<br>具体介绍略。</p>
<h2 id="8-2-location-对象"><a href="#8-2-location-对象" class="headerlink" title="8.2 location 对象"></a>8.2 location 对象</h2><p>location 是最有用的 BOM 对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。window.location 和 document.location 引用的是同一个对象。下表列出了 location 对象的所有属性：<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200323154259.png" alt="location属性"></p>
<h3 id="8-2-1-查询字符串参数"><a href="#8-2-1-查询字符串参数" class="headerlink" title="8.2.1 查询字符串参数"></a>8.2.1 查询字符串参数</h3><p>location.search 返回从问号到 URL 末尾的所有内容，但却没有办法逐个访问其中的每个查询字符串参数。为此，可以像下面这样创建一个函数，用以解析查询字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="comment">//取得查询字符串并去掉开头的问号 </span></span><br><span class="line">    <span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">""</span>), </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//保存数据的对象 </span></span><br><span class="line">    args = &#123;&#125;, </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//取得每一项 </span></span><br><span class="line">    items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : [], </span><br><span class="line">    item = <span class="literal">null</span>, name = <span class="literal">null</span>, value = <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">//在 for 循环中使用 </span></span><br><span class="line">    i = <span class="number">0</span>, </span><br><span class="line">    len = items.length;</span><br><span class="line">    <span class="comment">//逐个将每一项添加到 args 对象中 </span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; len; i++)&#123; </span><br><span class="line">        item = items[i].split(<span class="string">"="</span>); </span><br><span class="line">        name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]); </span><br><span class="line">        value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]); </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (name.length) &#123; </span><br><span class="line">            args[name] = value; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> args; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-2-位置操作"><a href="#8-2-2-位置操作" class="headerlink" title="8.2.2 位置操作"></a>8.2.2 位置操作</h3><p>使用 location 对象可以通过很多方式来改变浏览器的位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location.assign(<span class="string">"https://www.baidu.com"</span>); <span class="comment">// 跳转到百度</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">window</span>.location = <span class="string">"http://www.wrox.com"</span>; </span><br><span class="line">location.href = <span class="string">"http://www.wrox.com"</span>;</span><br></pre></td></tr></table></figure>
<p>另外，修改 location对象的其他属性也可以改变当前加载的页面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设初始 URL 为 http://www.wrox.com/WileyCDA/ </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//将 URL 修改为"http://www.wrox.com/WileyCDA/#section1" </span></span><br><span class="line">location.hash = <span class="string">"#section1"</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//将 URL 修改为"http://www.wrox.com/WileyCDA/?q=javascript" </span></span><br><span class="line">location.search = <span class="string">"?q=javascript"</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//将 URL 修改为"http://www.yahoo.com/WileyCDA/" </span></span><br><span class="line">location.hostname = <span class="string">"www.yahoo.com"</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//将 URL 修改为"http://www.yahoo.com/mydir/" </span></span><br><span class="line">location.pathname = <span class="string">"mydir"</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//将 URL 修改为"http://www.yahoo.com:8080/WileyCDA/" </span></span><br><span class="line">location.port = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure>
<p>每次修改 location 的属性（hash 除外），页面都会以新 URL 重新加载。<br>调用 replace()方法之后，用户不能回到前一个页面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location.replace(<span class="string">"http://www.wrox.com/"</span>);</span><br></pre></td></tr></table></figure>
<p>与位置有关的最后一个方法是 reload()，作用是重新加载当前显示的页面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location.reload();        <span class="comment">//重新加载（有可能从缓存中加载） </span></span><br><span class="line">location.reload(<span class="literal">true</span>);    <span class="comment">//重新加载（从服务器重新加载）</span></span><br></pre></td></tr></table></figure>

<h2 id="8-3-navigator-对象"><a href="#8-3-navigator-对象" class="headerlink" title="8.3 navigator 对象"></a>8.3 navigator 对象</h2><p>navigator 对象的属性通常用于检测显示网页的浏览器类型。</p>
<h3 id="8-3-1-检测插件"><a href="#8-3-1-检测插件" class="headerlink" title="8.3.1 检测插件"></a>8.3.1 检测插件</h3><p>检测浏览器中是否安装了特定的插件是一种最常见的检测例程。对于非 IE 浏览器，可以使用plugins 数组来达到这个目的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检测插件（在 IE 中无效） </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span>(<span class="params">name</span>)</span>&#123; </span><br><span class="line">    name = name.toLowerCase(); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; navigator.plugins.length; i++)&#123; </span><br><span class="line">        <span class="keyword">if</span> (navigator. plugins [i].name.toLowerCase().indexOf(name) &gt; <span class="number">-1</span>)&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//检测 Flash </span></span><br><span class="line">alert(hasPlugin(<span class="string">"Flash"</span>)); </span><br><span class="line"> </span><br><span class="line"><span class="comment">//检测 QuickTime </span></span><br><span class="line">alert(hasPlugin(<span class="string">"QuickTime"</span>));</span><br></pre></td></tr></table></figure>

<h3 id="8-3-2-注册处理程序"><a href="#8-3-2-注册处理程序" class="headerlink" title="8.3.2 注册处理程序"></a>8.3.2 注册处理程序</h3><p>registerContentHandler()和 registerProtocolHandler()方法可以让一个站点指明它可以处理特定类型的信息。随着 RSS 阅读器和在线电子邮件程序的兴起，注册处理程序就为像使用桌面应用程序一样默认使用这些在线应用程序提供了一种方式。<br>略。</p>
<h2 id="8-4-screen-对象"><a href="#8-4-screen-对象" class="headerlink" title="8.4 screen 对象"></a>8.4 screen 对象</h2><p>screen 对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200323194308.png" alt="screen对象的属性1"><br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200323194357.png" alt="screen对象的属性2"><br>这些信息经常集中出现在测定客户端能力的站点跟踪工具中，但通常不会用于影响功能。不过，有时候也可能会用到其中的信息来调整浏览器窗口大小，使其占据屏幕的可用空间。</p>
<h2 id="8-5-history-对象"><a href="#8-5-history-对象" class="headerlink" title="8.5 history 对象"></a>8.5 history 对象</h2><p>history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。每个浏览器窗口、每个标签页乃至每个框架，都有自己的 history 对象与特定的window 对象关联。<br>使用 go()方法可以在用户的历史记录中任意跳转。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后退一页 </span></span><br><span class="line">history.go(<span class="number">-1</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">//前进一页 </span></span><br><span class="line">history.go(<span class="number">1</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">//前进两页 </span></span><br><span class="line">history.go(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>也可以给 go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置。<br>history 对象还有一个 length 属性，保存着历史记录的数量。</p>
<h2 id="8-6-小结"><a href="#8-6-小结" class="headerlink" title="8.6 小结"></a>8.6 小结</h2><p>本章讨论了下列 BOM 的组成部分。 </p>
<ul>
<li>在使用框架时，每个框架都有自己的 window 对象以及所有原生构造函数及其他函数的副本。<br>每个框架都保存在 frames 集合中，可以通过位置或通过名称来访问。 </li>
<li>有一些窗口指针，可以用来引用其他框架，包括父框架。 </li>
<li>top 对象始终指向最外围的框架，也就是整个浏览器窗口。 </li>
<li>parent 对象表示包含当前框架的框架，而 self 对象则回指 window。 </li>
<li>使用 location 对象可以通过编程方式来访问浏览器的导航系统。设置相应的属性，可以逐段或整体性地修改浏览器的 URL。 </li>
<li>调用 replace()方法可以导航到一个新 URL，同时该 URL 会替换浏览器历史记录中当前显示的页面。 </li>
<li>navigator 对象提供了与浏览器有关的信息。</li>
</ul>
<p>BOM 中还有两个对象：screen 和 history。screen 对象中保存着与客户端显示器有关的信息，这些信息一般只用于站点分析。history 对象为访问浏览器的历史记录开了一个小缝隙，开发人员可以据此判断历史记录的数量，也可以在历史记录中向后或向前导航到任意页面。 </p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>第七章 - 函数表达式</title>
    <url>/2020/03/22/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB-JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-22-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>本章内容 </p>
<ul>
<li>函数表达式的特征 </li>
<li>使用函数实现递归 </li>
<li>使用闭包定义私有变量</li>
</ul>
<p>定义函数的方式有两种：一种是函数声明，另一种就是函数表达式。函数声明的语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">arg0, arg1, arg2</span>) </span>&#123; </span><br><span class="line">    <span class="comment">//函数体 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于函数声明，它的一个重要特征就是<strong>函数声明提升</strong>（function declaration hoisting），在执行代码之前会先读取函数声明。<br>第二种创建函数的方式是使用函数表达式，常见的形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params">arg0, arg1, arg2</span>)</span>&#123; </span><br><span class="line">    <span class="comment">//函数体  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种情况下创建的函数叫做<strong>匿名函数</strong>（anonymous function），因为 function 关键字后面没有标识符。在使用前<strong>必须先赋值</strong>。<br>理解函数提升的关键，就是理解函数声明与函数表达式之间的区别。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不要这样做！  </span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        alert(<span class="string">"Hi!"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        alert(<span class="string">"Yo!"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大多数浏览器会返回第二个声明，忽略condition；使用函数表达式可以避免此问题。</p>
<h2 id="7-1-递归"><a href="#7-1-递归" class="headerlink" title="7.1 递归"></a>7.1 递归</h2><p>使用 arguments.callee来代替一个函数通过名字调用自身。在严格模式下可使用命名函数表达式来达到相同效果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> num * f(num<span class="number">-1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="7-2-闭包"><a href="#7-2-闭包" class="headerlink" title="7.2 闭包"></a>7.2 闭包</h2><p>闭包是指有权访问另一个函数作用域中的变量的函数（因为内部函数的作用域链包含了外部函数的作用域，详见第四章）。创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">createComparisonFunction()函数为例，注意加粗的代码。 </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123; </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span>&#123; </span><br><span class="line">        <span class="keyword">var</span> value1 = object1[propertyName]; </span><br><span class="line">        <span class="keyword">var</span> value2 = object2[propertyName]; </span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2)&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面简要回顾关于作用域的概念：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2)&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> result = compare(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>下图展示了作用域链：<br><img src="http://q7l5moftw.bkt.clouddn.com/20200322184914.png" alt="compare的作用域链"><br>在创建 compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。<br>一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，<strong>闭包的情况又有所不同</strong>。<br>createComparisonFunction()函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当 createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到匿名函数被销毁后，createComparisonFunction()的活动对象才会被销毁。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建函数 </span></span><br><span class="line"><span class="keyword">var</span> compareNames = createComparisonFunction(<span class="string">"name"</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">//调用函数 </span></span><br><span class="line"><span class="keyword">var</span> result = compareNames(&#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">"Greg"</span> &#125;); </span><br><span class="line"> </span><br><span class="line"><span class="comment">//解除对匿名函数的引用（以便释放内存） </span></span><br><span class="line">compareNames = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>下图展示了调用compareNames()过程中产生的作用域链之间的关系：<br><img src="http://q7l5moftw.bkt.clouddn.com/20200322185839.png" alt="作用域链之间的关系"></p>
<blockquote>
<p>由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。所以要慎重使用闭包。</p>
</blockquote>
<h3 id="7-2-1-闭包与变量"><a href="#7-2-1-闭包与变量" class="headerlink" title="7.2.1 闭包与变量"></a>7.2.1 闭包与变量</h3><p>作用域链的这种配置机制引出了一个值得注意的副作用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123; </span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">            <span class="keyword">return</span> i; </span><br><span class="line">        &#125;; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表面上看，似乎每个函数都应该返自己的索引值，即位置 0 的函数返回 0，位置 1 的函数返回 1，以此类推。但实际上，每个函数都返回 10。因为当createFunctions()函数返回后，变量 i 的值是 10，此时每个函数都引用着保存变量 i 的同一个变量对象。<br>我们可以通过创建另一个匿名函数强制让闭包的行为符合预期。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123; </span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">                <span class="keyword">return</span> num; </span><br><span class="line">            &#125;; </span><br><span class="line">        &#125;(i); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-2-关于this对象"><a href="#7-2-2-关于this对象" class="headerlink" title="7.2.2 关于this对象"></a>7.2.2 关于this对象</h3><p>在闭包中使用 this 对象也可能会导致一些问题。我们知道，this 对象是在运行时基于函数的执行环境绑定的。匿名函数的执行环境具有全局性，因此<strong>其 this 对象通常指向 window</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> object = &#123; </span><br><span class="line">    name : <span class="string">"My Object"</span>, </span><br><span class="line"> </span><br><span class="line">    getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name; </span><br><span class="line">        &#125;; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">alert(object.getNameFunc()());  <span class="comment">//"The Window"（在非严格模式下） </span></span><br><span class="line"><span class="comment">// 和匿名函数就体现了区别</span></span><br></pre></td></tr></table></figure>
<p>把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里（比如下面的that），就可以让闭包访问该对象了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> object = &#123; </span><br><span class="line">    name : <span class="string">"My Object"</span>, </span><br><span class="line"> </span><br><span class="line">    getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">            <span class="keyword">return</span> that.name; </span><br><span class="line">        &#125;; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>arguments 也存在同样的问题。如果想访问作用域中的 arguments 对象，必须将对该对象的引用保存到另一个闭包能够访问的变量中。 </p>
</blockquote>
<p>在几种特殊情况下，this 的值可能会意外地改变：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> object = &#123; </span><br><span class="line">    name : <span class="string">"My Object"</span>, </span><br><span class="line"> </span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line">object.getName();   <span class="comment">//"My Object" </span></span><br><span class="line">(object.getName)(); <span class="comment">//"My Object" </span></span><br><span class="line">(object.getName = object.getName)(); <span class="comment">//"The Window"，在非严格模式下</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-3-内存泄漏"><a href="#7-2-3-内存泄漏" class="headerlink" title="7.2.3 内存泄漏"></a>7.2.3 内存泄漏</h3><p>IE9 之前的版本导致闭包在 IE 的这些版本中会导致一些特殊的问题。</p>
<h2 id="7-3-模仿块级作用域"><a href="#7-3-模仿块级作用域" class="headerlink" title="7.3 模仿块级作用域"></a>7.3 模仿块级作用域</h2><p>匿名函数可以用来模仿块级作用域:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="comment">//这里是块级作用域 </span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。</p>
</blockquote>
<p>无论在什么地方，只要临时需要一些变量，就可以使用私有作用域：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>)</span>&#123; </span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; count; i++)&#123; </span><br><span class="line">            alert(i); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;)(); </span><br><span class="line">     </span><br><span class="line">    alert(i);   <span class="comment">//导致一个错误！ </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在私有作用域中能够访问变量 count，是因为这个匿名函数是一个闭包，它能够访问包含作用域中的所有变量。这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。（JS的确是挺麻烦的语言，ES6的let是不是改善了这个？）</p>
<h2 id="7-4-私有变量-（和上一节的内容混起来有点乱。。。）"><a href="#7-4-私有变量-（和上一节的内容混起来有点乱。。。）" class="headerlink" title="7.4 私有变量 （和上一节的内容混起来有点乱。。。）"></a>7.4 私有变量 （和上一节的内容混起来有点乱。。。）</h2><p>严格来讲，JavaScript 中没有私有成员的概念；所有对象属性都是公有的。但有<strong>私有变量的概念</strong>：任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。<br>我们把有权访问私有变量和私有函数的公有方法称为特权方法（privileged method）。两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式如下。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//私有变量和私有函数 </span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//特权方法 </span></span><br><span class="line">    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">        privateVariable++; </span><br><span class="line">        <span class="keyword">return</span> privateFunction(); </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问（因为作用域链）在构造函数中定义的所有变量和函数。<br>不过，在构造函数中定义特权方法也有一个缺点，那就是你必须使用构造函数模式来达到这个目的。而构造函数模式的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。 </p>
<h3 id="7-4-1-静态私有变量"><a href="#7-4-1-静态私有变量" class="headerlink" title="7.4.1 静态私有变量"></a>7.4.1 静态私有变量</h3><p>略</p>
<h3 id="7-4-2-模块模式"><a href="#7-4-2-模块模式" class="headerlink" title="7.4.2 模块模式"></a>7.4.2 模块模式</h3><p>略</p>
<h3 id="7-4-3-增强的模块模式"><a href="#7-4-3-增强的模块模式" class="headerlink" title="7.4.3 增强的模块模式"></a>7.4.3 增强的模块模式</h3><p>略</p>
<h2 id="7-5-小结"><a href="#7-5-小结" class="headerlink" title="7.5 小结"></a>7.5 小结</h2><p>在 JavaScript 编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用 JavaScript 函数的强大方式。以下总结了函数表达式的特点。</p>
<ul>
<li>函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫做匿名函数。 </li>
<li>在无法确定如何引用函数的情况下，递归函数就会变得比较复杂； </li>
<li>递归函数应该始终使用 arguments.callee 来递归地调用自身，不要使用函数名——函数名可能会发生变化。 </li>
</ul>
<p>当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下。 </p>
<ul>
<li>在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。</li>
<li>通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。 </li>
<li>但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。 </li>
</ul>
<p>使用闭包可以在 JavaScript 中模仿块级作用域（JavaScript 本身没有块级作用域的概念），要点如下。 </p>
<ul>
<li>创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。</li>
<li>结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。 </li>
</ul>
<p>闭包还可以用于在对象中创建私有变量，相关概念和要点如下。 </p>
<ul>
<li>即使 JavaScript 中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量。 </li>
<li>有权访问私有变量的公有方法叫做特权方法。 </li>
<li>可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。 </li>
</ul>
<p>JavaScript 中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为<br>创建闭包必须维护额外的作用域，所以过度使用它们<strong>可能会占用大量内存</strong>。 </p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>第六章 - 面向对象的程序设计</title>
    <url>/2020/03/21/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB-JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-21-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>本章内容 </p>
<ul>
<li>理解对象属性 </li>
<li>理解并创建对象 </li>
<li>理解继承</li>
</ul>
<p>ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。</p>
<h2 id="6-1-理解对象"><a href="#6-1-理解对象" class="headerlink" title="6.1 理解对象"></a>6.1 理解对象</h2><p>上一章曾经介绍过，如何创建一个 Object 的实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">person.name = <span class="string">"Nicholas"</span>; </span><br><span class="line">person.age = <span class="number">29</span>;  </span><br><span class="line">person.job = <span class="string">"Software Engineer"</span>; </span><br><span class="line"> </span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="keyword">this</span>.name);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>后来，使用对象字面量语法来写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; </span><br><span class="line">    name: <span class="string">"Nicholas"</span>,  </span><br><span class="line">    age: <span class="number">29</span>, </span><br><span class="line">    job: <span class="string">"Software Engineer"</span>, </span><br><span class="line"> </span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        alert(<span class="keyword">this</span>.name); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-1-属性类型"><a href="#6-1-1-属性类型" class="headerlink" title="6.1.1 属性类型"></a>6.1.1 属性类型</h3><p>ECMAScript 中有两种属性：数据属性和访问器属性。 </p>
<ul>
<li>数据属性</li>
</ul>
<p>数据属性包含一个数据值的位置。在这个位置可以读取和写入值。每个数据属性有4个描述其行为的特性：</p>
<ul>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 </li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 </li>
<li>[[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 </li>
<li>[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; </span><br><span class="line"> name: <span class="string">"Nicholas"</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个名为 name 的属性，[[Value]]特性将被设置为”Nicholas”，其它三个属性默认为true。<br>要修改属性默认的特性，必须使用 ECMAScript 5 的 Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;; </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123; </span><br><span class="line">    writable: <span class="literal">false</span>, <span class="comment">// 不可写，只读</span></span><br><span class="line">    value: <span class="string">"Nicholas"</span>  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>把 <strong>configurable</strong> 设置为 false，表示不能从对象中删除属性。而且，一旦把属性定义为不可配置的，就不能再把它变回可配置了。多数情况下，可能都没有必要利用 Object.defineProperty()，不过对于帮助理解JS对象是有用的。</p>
<ul>
<li>访问器属性</li>
</ul>
<p>访问器属性不包含数据值；它们包含一对儿 getter 和 setter 函数。在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下 4 个特性：</p>
<ul>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性。默认ture</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。默认ture</li>
<li>[[Get]]：在读取属性时调用的函数。默认值为 undefined。 </li>
<li>[[Set]]：在写入属性时调用的函数。默认值为 undefined。</li>
</ul>
<p>访问器属性不能直接定义，必须使用 <strong>Object.defineProperty()</strong>来定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123; </span><br><span class="line">    _year: <span class="number">2004</span>,  </span><br><span class="line">    edition: <span class="number">1</span> </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123; </span><br><span class="line">    <span class="keyword">get</span>: function()&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year; </span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="keyword">set</span>: function(newValue)&#123; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123; </span><br><span class="line">            <span class="keyword">this</span>._year = newValue; </span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;); </span><br><span class="line"> </span><br><span class="line">book.year = <span class="number">2005</span>; </span><br><span class="line">alert(book.edition);  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>其中”year”就是访问器属性year，包含getter函数和setter函数。</p>
<h3 id="6-1-2-定义多个属性"><a href="#6-1-2-定义多个属性" class="headerlink" title="6.1.2 定义多个属性"></a>6.1.2 定义多个属性</h3><p>Object.defineProperties()可以通过描述符一次定义多个属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123; </span><br><span class="line">    _year: &#123;  </span><br><span class="line">        value: <span class="number">2004</span> </span><br><span class="line">    &#125;, </span><br><span class="line"> </span><br><span class="line">    edition: &#123; </span><br><span class="line">        value: <span class="number">1</span> </span><br><span class="line">    &#125;, </span><br><span class="line"> </span><br><span class="line">    year: &#123; </span><br><span class="line">        <span class="keyword">get</span>: function()&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._year; </span><br><span class="line">        &#125;, </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">set</span>: function(newValue)&#123; </span><br><span class="line">            <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123; </span><br><span class="line">                <span class="keyword">this</span>._year = newValue; </span><br><span class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="6-1-3-读取属性的特性"><a href="#6-1-3-读取属性的特性" class="headerlink" title="6.1.3 读取属性的特性"></a>6.1.3 读取属性的特性</h3><p>使用 ECMAScript 5 的 Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这个对象的属性有 configurable、enumerable、writable 和 value。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接上一代码块</span></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>); </span><br><span class="line">alert(descriptor.value);         <span class="comment">//2004 </span></span><br><span class="line">alert(descriptor.configurable); <span class="comment">//false</span></span><br><span class="line">alert(<span class="keyword">typeof</span> descriptor.get);    <span class="comment">//"undefined" </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"year"</span>); </span><br><span class="line">alert(descriptor.value);        <span class="comment">//undefined </span></span><br><span class="line">alert(descriptor.enumerable);   <span class="comment">//false </span></span><br><span class="line">alert(<span class="keyword">typeof</span> descriptor.get);   <span class="comment">//"function"</span></span><br></pre></td></tr></table></figure>

<h2 id="6-2-创建对象"><a href="#6-2-创建对象" class="headerlink" title="6.2 创建对象"></a>6.2 创建对象</h2><p>使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。</p>
<h3 id="6-2-1-工厂模式"><a href="#6-2-1-工厂模式" class="headerlink" title="6.2.1 工厂模式"></a>6.2.1 工厂模式</h3><p>工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。考虑到在 ECMAScript 中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">    o.name = name; </span><br><span class="line">    o.age = age; </span><br><span class="line">    o.job = job; </span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        alert(<span class="keyword">this</span>.name); </span><br><span class="line">    &#125;;     </span><br><span class="line">    <span class="keyword">return</span> o; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>); </span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>
<p>工厂模式虽然解决了创建多个相似对象的问题，<strong>但却没有解决对象识别的问题（即怎样知道一个对象的类型）</strong>。随着 JavaScript的发展，又一个新模式出现了。 </p>
<h3 id="6-2-2-构造函数模式"><a href="#6-2-2-构造函数模式" class="headerlink" title="6.2.2 构造函数模式"></a>6.2.2 构造函数模式</h3><p>创建自定义的构造函数，从而定义自定义对象类型的属性和方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name; </span><br><span class="line">    <span class="keyword">this</span>.age = age; </span><br><span class="line">    <span class="keyword">this</span>.job = job; </span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        alert(<span class="keyword">this</span>.name); </span><br><span class="line">    &#125;;     </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>
<p>与工厂模式的不同之处：</p>
<ul>
<li>没有显式地创建对象； </li>
<li>直接将属性和方法赋给了 this 对象； </li>
<li>没有 return 语句。 </li>
<li>函数名 Person 使用的是大写字母 P。</li>
</ul>
<p>person1 和 person2 分别保存着 Person 的一个不同的实例。这两个对象都有一个 constructor（构造函数）属性，该属性指向 Person。</p>
<ul>
<li>将构造函数当作函数 </li>
</ul>
<p>构造函数与其他函数的<strong>唯一区别</strong>，就在于调用它们的方式不同。任何函数，只要<strong>通过 new 操作符</strong>来调用，那它就可以作为构造函数；而任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当作构造函数使用 </span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>); </span><br><span class="line">person.sayName(); <span class="comment">//"Nicholas" </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 作为普通函数调用 </span></span><br><span class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>); <span class="comment">// 添加到 window </span></span><br><span class="line"><span class="built_in">window</span>.sayName(); <span class="comment">//"Greg" </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用 </span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">Person.call(o, <span class="string">"Kristen"</span>, <span class="number">25</span>, <span class="string">"Nurse"</span>); </span><br><span class="line">o.sayName(); <span class="comment">//"Kristen"</span></span><br></pre></td></tr></table></figure>
<p>不使用 new操作符调用 Person()会出现什么结果：属性和方法都被添加给 window对象了，因为当在全局作用域中调用一个函数时，this 对象总是指向 Global 对象。使用 call()（或者 apply()）在某个特殊对象的作用域中调用 Person()函数。这里是在对象 o的作用域中调用的，因此调用后 o就拥有了所有属性和 sayName()方法。 </p>
<ul>
<li>构造函数的问题</li>
</ul>
<p>使用构造函数的<strong>主要问题</strong>，就是每个方法都要在每个实例上重新创建一遍。ECMAScript 中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name; </span><br><span class="line">    <span class="keyword">this</span>.age = age; </span><br><span class="line">    <span class="keyword">this</span>.job = job; </span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"alert(this.name)"</span>); <span class="comment">// 与声明函数在逻辑上是等价的 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个角度上来看构造函数，更容易明白每个 Person 实例都包含一个不同的 Function 实例。<br>不同实例上的同名函数是不相等的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(person1.sayName == person2.sayName);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>对于这个问题，可以通过把函数定义转移到构造函数外部来解决这个问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name; </span><br><span class="line">    <span class="keyword">this</span>.age = age; </span><br><span class="line">    <span class="keyword">this</span>.job = job; </span><br><span class="line">    <span class="keyword">this</span>.sayName = sayName; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="keyword">this</span>.name); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>
<p>可是<strong>新问题</strong>又来了：像这样在全局作用域定义的函数只能被某个对象调用，这让全局作用域有点名不副实；而且若对象需要定义多个方法，则需要定义多个全局函数，那么这些自定义的引用类型就没有封装性可言。可以通过原型模式来解决。</p>
<h3 id="6-2-3-原型模式"><a href="#6-2-3-原型模式" class="headerlink" title="6.2.3 原型模式"></a>6.2.3 原型模式</h3><p>我们创建的<strong>每个函数都有</strong>一个 <strong>prototype</strong>（原型）属性，这个属性是一个指针，指向一个对象。而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。那么就不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下面的例子所示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>; </span><br><span class="line">Person.prototype.age = <span class="number">29</span>; </span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>; </span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="keyword">this</span>.name); </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line">person1.sayName();   <span class="comment">//"Nicholas" </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(); </span><br><span class="line">person2.sayName();   <span class="comment">//"Nicholas" </span></span><br><span class="line"> </span><br><span class="line">alert(person1.sayName == person2.sayName);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>但与构造函数模式不同的是，<strong>新对象的这些属性和方法是由所有实例共享的</strong>。要理解原型模式的工作原理，必须先理解 ECMAScript 中原型对象的性质。 </p>
<ul>
<li>理解原型对象</li>
</ul>
<p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。就拿前面的例子来说，Person.prototype.constructor 指向 Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype <span class="comment">// 这个属性指向函数的原型对象</span></span><br><span class="line">Person.prototype.constructor <span class="comment">// 指针指向构造函数本身，即Person</span></span><br></pre></td></tr></table></figure>
<p>创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性；至于其他方法，则都是从 Object 继承而来的（如下图所示）。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> LiMing = <span class="keyword">new</span> Person()</span><br><span class="line">LiMing.__proto__ <span class="comment">// 指向构造函数的原型对象，即prototype</span></span><br></pre></td></tr></table></figure>

<div  align="center">    
    <img src="/images/constructor.png"/>
</div>

<div  align="center">    
    <img src="/images/Person_relation.png" width='974' height='451'/>
</div>

<p>图 6-1 展示了 Person 构造函数、Person 的原型属性以及 Person 现有的两个实例之间的关系。要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用 person1.sayName()。这是通过<strong>查找对象属性</strong>的过程来实现的。<br>虽然在所有实现中都无法访问到[[Prototype]]，但可以通过 <strong>isPrototypeOf()</strong>方法来确定对象之间是否存在这种关系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(Person.prototype.isPrototypeOf(person1));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript 5 增加了一个新方法，叫 <strong>Object.getPrototypeOf()</strong>，在所有支持的实现中，这个方法返回[[Prototype]]的值。这在利用原型实现继承（本章稍后会讨论）的情况下是非常重要的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。<br>虽然可以通过对象实例访问保存在原型中的值，但却<strong>不能通过对象实例重写原型中的值</strong>。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个<strong>属性同名</strong>，那我们就在实例中创建该属性，该属性将会<strong>屏蔽原型中的那个属性</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>; </span><br><span class="line">Person.prototype.age = <span class="number">29</span>; </span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>; </span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="keyword">this</span>.name); </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(); </span><br><span class="line"> </span><br><span class="line">person1.name = <span class="string">"Greg"</span>; </span><br><span class="line">alert(person1.name);     <span class="comment">//"Greg"——来自实例 </span></span><br><span class="line">alert(person2.name);     <span class="comment">//"Nicholas"——来自原型</span></span><br></pre></td></tr></table></figure>
<p>不过，使用 delete 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接上</span></span><br><span class="line"><span class="keyword">delete</span> person1.name; </span><br><span class="line">alert(person1.name);     <span class="comment">//"Nicholas"——来自原型</span></span><br></pre></td></tr></table></figure>
<p>使用 <strong>hasOwnProperty()</strong>方法（继承自Object）可以检测一个属性是存在于实例中，还是存在于原型中。该方法只在给定属性存在于对象实例中时，才会返回 true。<br>图 6-2 展示了上面例子反映的关系：</p>
<div  align="center">    
    <img src="/images/photo_6_2.png" width='840' height='760'/>
</div>

<ul>
<li>原型与 in 操作符</li>
</ul>
<p>有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。<br>在单独使用时，<strong>in 操作符</strong>会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125; </span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>; </span><br><span class="line">Person.prototype.age = <span class="number">29</span>; </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(); </span><br><span class="line"> </span><br><span class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>));  <span class="comment">//false </span></span><br><span class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> person1);  <span class="comment">//true </span></span><br><span class="line"> </span><br><span class="line">person1.name = <span class="string">"Greg"</span>; </span><br><span class="line">alert(person1.name);   <span class="comment">//"Greg" ——来自实例 </span></span><br><span class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>));  <span class="comment">//true </span></span><br><span class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> person1);  <span class="comment">//true </span></span><br><span class="line"> </span><br><span class="line">alert(person2.name);   <span class="comment">//"Nicholas" ——来自原型 </span></span><br><span class="line">alert(person2.hasOwnProperty(<span class="string">"name"</span>));  <span class="comment">//false </span></span><br><span class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> person2);  <span class="comment">//true </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">delete</span> person1.name; </span><br><span class="line">alert(person1.name);   <span class="comment">//"Nicholas" ——来自原型 </span></span><br><span class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>));  <span class="comment">//false </span></span><br><span class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> person1);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>由hasOwnProperty()和in操作符可定义hasPrototypeProperty()函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用 <strong>for-in</strong> 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记为 false 的属性）的实例属性也会在 for-in 循环中返回。<br>要取得对象上所有可枚举的实例属性，可以使用 ECMAScript 5 的 <strong>Object.keys()</strong>方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>; </span><br><span class="line">Person.prototype.age = <span class="number">29</span>; </span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>; </span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="keyword">this</span>.name);  </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(Person.prototype); </span><br><span class="line">alert(keys);       <span class="comment">// ["name,age,job,sayName"] </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(); </span><br><span class="line">p1.name = <span class="string">"Rob"</span>; </span><br><span class="line">p1.age = <span class="number">31</span>; </span><br><span class="line"><span class="keyword">var</span> p1keys = <span class="built_in">Object</span>.keys(p1); </span><br><span class="line">alert(p1keys);    <span class="comment">// ["name,age"]</span></span><br></pre></td></tr></table></figure>
<p>如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 Object.getOwnPropertyNames()方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype); </span><br><span class="line">alert(keys);    <span class="comment">//"constructor,name,age,job,sayName"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>更简单的原型语法</li>
</ul>
<p>前面例子中每添加一个属性和方法就要敲一遍 Person.prototype。为减少不必要的输入，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">Person.prototype = &#123; </span><br><span class="line">    name : <span class="string">"Nicholas"</span>, </span><br><span class="line">    age : <span class="number">29</span>, </span><br><span class="line">    job: <span class="string">"Software Engineer"</span>, </span><br><span class="line">    sayName : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        alert(<span class="keyword">this</span>.name); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但这造成了一个问题：constructor 属性不再指向 Person 了，因为这里使用的语法，本质上完全重写了默认的 prototype 对象，因此 constructor 属性也就变成了新对象的 constructor 属性（指向 Object 构造函数），不再指向 Person 函数。此时通过 constructor 已经无法确定对象的类型了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(); </span><br><span class="line"> </span><br><span class="line">alert(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true </span></span><br><span class="line">alert(friend <span class="keyword">instanceof</span> Person); <span class="comment">//true </span></span><br><span class="line">alert(friend.constructor == Person);    <span class="comment">//false </span></span><br><span class="line">alert(friend.constructor == <span class="built_in">Object</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>可以像下面这样特意将它设置回适当的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">Person.prototype = &#123; </span><br><span class="line">    <span class="keyword">constructor</span> : Person, </span><br><span class="line">    name : "Nicholas", </span><br><span class="line">    age : 29, </span><br><span class="line">    job: "Software Engineer", </span><br><span class="line">    sayName : function () &#123; </span><br><span class="line">        alert(<span class="keyword">this</span>.name); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，以这种方式重设 constructor 属性会导致它的[[Enumerable]]特性被设置为 true。可以试一试 Object.defineProperty()来解决此问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">Person.prototype = &#123; </span><br><span class="line">    name : <span class="string">"Nicholas"</span>, </span><br><span class="line">    age : <span class="number">29</span>, </span><br><span class="line">    job : <span class="string">"Software Engineer"</span>, </span><br><span class="line">    sayName : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        alert(<span class="keyword">this</span>.name); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">//重设构造函数，只适用于 ECMAScript 5 兼容的浏览器 </span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123; </span><br><span class="line">    enumerable: <span class="literal">false</span>, </span><br><span class="line">    value: Person </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>原型的动态性</li>
</ul>
<p>我们对原型对象所做的任何修改都能够<strong>立即从实例上反映</strong>出来——即使是先创建了实例后修改原型也照样如此。（因为实例与原型之间的连接只不过是一个指针，而非一个副本）<br>但如果是<strong>重写整个原型对象</strong>，即把原型修改为另外一个对象，就等于切断了构造函数与最初原型之间的联系。请记住：实例中的指针仅指向原型，而不指向构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(); </span><br><span class="line">         </span><br><span class="line">Person.prototype = &#123; <span class="comment">// 重写了prototype</span></span><br><span class="line">    <span class="keyword">constructor</span>: Person, </span><br><span class="line">    name : "Nicholas", </span><br><span class="line">    age : 29, </span><br><span class="line">    job : "Software Engineer", </span><br><span class="line">    sayName : function () &#123; </span><br><span class="line">        alert(<span class="keyword">this</span>.name); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">friend.sayName();   <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<div  align="center">    
    <img src="/images/photo_6_3.png" width='811' height='631'/>
</div>

<ul>
<li>原生对象的原型</li>
</ul>
<p>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.startsWith = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.indexOf(text) == <span class="number">0</span>; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">"Hello world!"</span>; </span><br><span class="line">alert(msg.startsWith(<span class="string">"Hello"</span>));   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>尽管可以这样做，但我们不推荐在产品化的程序中修改原生对象的原型。</p>
</blockquote>
<ul>
<li>原型对象的问题</li>
</ul>
<p>首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。但还有一个，原型模式的最大问题是由其共享的本性所导致的。<br>对于<strong>包含引用类型值的属性</strong>来说，问题就比较突出了。来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">Person.prototype = &#123; </span><br><span class="line">    <span class="keyword">constructor</span>: Person, </span><br><span class="line">    name : "Nicholas", </span><br><span class="line">    age : 29, </span><br><span class="line">    job : "Software Engineer", </span><br><span class="line">    friends : ["Shelby", "Court"], </span><br><span class="line">    sayName : function () &#123; </span><br><span class="line">        alert(<span class="keyword">this</span>.name); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(); </span><br><span class="line"> </span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>); </span><br><span class="line"> </span><br><span class="line">alert(person1.friends);    <span class="comment">//"Shelby,Court,Van" </span></span><br><span class="line">alert(person2.friends);    <span class="comment">//"Shelby,Court,Van" </span></span><br><span class="line">alert(person1.friends === person2.friends);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>修改了 person1.friends <strong>引用</strong>的数组，向数组中添加了一个字符串。所以刚刚提到的修改也会通过person2.friends（与 person1.friends 指向同一个数组）反映出来。而这个问题正是我们<strong>很少看到有人单独使用原型模式</strong>的原因所在。 </p>
<p><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/3_22_aboutYX.png" alt=""></p>
<h3 id="6-2-4-组合使用构造函数模式和原型模式"><a href="#6-2-4-组合使用构造函数模式和原型模式" class="headerlink" title="6.2.4 组合使用构造函数模式和原型模式"></a>6.2.4 组合使用构造函数模式和原型模式</h3><p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。<strong>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</strong>结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混合模式还支持向构造函数传递参数；可谓是集两种模式之长：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name; </span><br><span class="line">    <span class="keyword">this</span>.age = age; </span><br><span class="line">    <span class="keyword">this</span>.job = job; </span><br><span class="line">    <span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>]; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">Person.prototype = &#123; </span><br><span class="line">    <span class="keyword">constructor</span> : Person, </span><br><span class="line">    sayName : function()&#123; </span><br><span class="line">        alert(<span class="keyword">this</span>.name); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>); </span><br><span class="line"> </span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>); </span><br><span class="line">alert(person1.friends);    <span class="comment">//"Shelby,Count,Van" </span></span><br><span class="line">alert(person2.friends);    <span class="comment">//"Shelby,Count" </span></span><br><span class="line">alert(person1.friends === person2.friends);    <span class="comment">//false </span></span><br><span class="line">alert(person1.sayName === person2.sayName);    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>这种构造函数与原型混成的模式，是目前在 ECMAScript 中<strong>使用最广泛、认同度最高</strong>的一种创建自定义类型的方法。</p>
<h3 id="6-2-5-动态原型模式"><a href="#6-2-5-动态原型模式" class="headerlink" title="6.2.5 动态原型模式"></a>6.2.5 动态原型模式</h3><p>有其他 OO 语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常困惑，于是就有了动态原型模式这个解决方案：它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。来看一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//属性 </span></span><br><span class="line">    <span class="keyword">this</span>.name = name; </span><br><span class="line">    <span class="keyword">this</span>.age = age; </span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="comment">//方法, 体现了动态添加=.=</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123; </span><br><span class="line">     </span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">            alert(<span class="keyword">this</span>.name); </span><br><span class="line">        &#125;; </span><br><span class="line">         </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>); </span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure>
<p>这段代码只会在初次调用构造函数时才会执行。其中if 语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆<br>if 语句检查每个属性和每个方法；<strong>只要检查其中一个即可</strong>。</p>
<blockquote>
<p>使用动态原型模式时，不能使用对象字面量重写原型，因为会切断现有实例与新原型之间的联系。</p>
</blockquote>
<h3 id="6-2-6-寄生构造函数模式"><a href="#6-2-6-寄生构造函数模式" class="headerlink" title="6.2.6 寄生构造函数模式"></a>6.2.6 寄生构造函数模式</h3><p>通常，在前述的几种模式都不适用的情况下，可以使用<strong>寄生（parasitic）构造函数模式</strong>。这种模式的<strong>基本思想</strong>是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。下面是一个例子（和前文看过的工厂模式很像，区别于是否有new）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">    o.name = name; </span><br><span class="line">    o.age = age; </span><br><span class="line">    o.job = job; </span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        alert(<span class="keyword">this</span>.name); </span><br><span class="line">    &#125;;     </span><br><span class="line">    <span class="keyword">return</span> o; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>); </span><br><span class="line">friend.sayName();  <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式是一模一样的。<br>构造函数在不返回值的情况下，默认会返回新对象实例（这也是为什么构造函数模式不用写return的原因:)）。而通过在构造函数的末尾添加一个 return 语句，可以重写调用构造函数时返回的值。<br>这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改 Array 构造函数，因此可以使用这个模式。<br>关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖 instanceof 操作符来确定对象类型。</p>
<h3 id="6-2-7-稳妥构造函数模式"><a href="#6-2-7-稳妥构造函数模式" class="headerlink" title="6.2.7 稳妥构造函数模式"></a>6.2.7 稳妥构造函数模式</h3><p>道格拉斯·克罗克福德（Douglas Crockford）发明了 JavaScript 中的<strong>稳妥对象</strong>（durable objects）这个概念。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序（如 Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用 this；二是不使用 new 操作符调用构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//创建要返回的对象 </span></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">    <span class="comment">//可以在这里定义私有变量和函数 </span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//添加方法 </span></span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        alert(name); </span><br><span class="line">    &#125;;     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//返回对象 </span></span><br><span class="line">    <span class="keyword">return</span> o; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> friend = Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>); </span><br><span class="line">friend.sayName();  <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>除了调用 sayName()方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。</p>
<blockquote>
<p>与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此 instanceof 操作符对这种对象也没有意义。</p>
</blockquote>
<h2 id="6-3-继承"><a href="#6-3-继承" class="headerlink" title="6.3 继承"></a>6.3 继承</h2><p>许多 OO 语言都支持两种继承方式：<strong>接口继承</strong>和<strong>实现继承</strong>。接口继承只继承方法签名，而实现继承则继承实际的方法。ECMAScript 只支持实现继承，而且其实现继承主要是依靠<strong>原型链</strong>来实现的。 </p>
<h3 id="6-3-1-原型链"><a href="#6-3-1-原型链" class="headerlink" title="6.3.1 原型链"></a>6.3.1 原型链</h3><p>原型链基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。<br>假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？实现原型链有一种基本模式，其代码大致如下。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//继承了 SuperType </span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line"> </span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(); </span><br><span class="line">alert(instance.getSuperValue());      <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>SubType 继承了 SuperType，而继承是通过创建 SuperType 的实例，并将该实例赋给SubType.prototype 实现的。实现的本质是重写原型对象，代之以一个新类型的实例。即原来存在于 SuperType 的实例中的所有属性和方法，现在也存在于 SubType.prototype 中了。<br>这个例子中的实例以及构造函数和原型之间的关系如图所示：</p>
<div  align="center">    
    <img src="/images/photo_6_4.png" width='800' height='385'/>
</div>

<div  align="center">    
    <img src="/images/photo_6_4_2.png" width='434' height='240'/>
</div>

<p>要注意 instance.constructor 现在指向的是 SuperType，这是因为原来 SubType.prototype 中的 constructor 被重写了的缘故。</p>
<ul>
<li>别忘记默认的原型</li>
</ul>
<p>默认原型都会包含一个内部指针，指向 Object.prototype。这也正是所有自定义类型都会继承 toString()、valueOf()等默认方法的根本原因。下图展示完整的原型链。</p>
<div  align="center">    
    <img src="/images/photo_6_5.png" width='821' height='655'/>
</div>

<ul>
<li>确定原型和实例的关系</li>
</ul>
<p>第一种方式是使用 instanceof 操作符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true </span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SuperType); <span class="comment">//true </span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SubType);         <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>第二种方式是使用 isPrototypeOf()方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance));         <span class="comment">//true </span></span><br><span class="line">alert(SuperType.prototype.isPrototypeOf(instance));      <span class="comment">//true </span></span><br><span class="line">alert(SubType.prototype.isPrototypeOf(instance));        <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>谨慎地定义方法</li>
</ul>
<p>注意给原型添加方法的代码一定要放在替换原型的语句之后（因为是对SuperType实例的添加修改，根据前文所学，这样做本身就会屏蔽SuperType原有的相同属性、方法）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// SuperType 的实例替换SubType原型，继承了 SuperType </span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">//添加新方法 </span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//重写超类型中的方法 </span></span><br><span class="line">SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还有一点，在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链。（也是前文所学，会丢失constructor，变成指向Object对象）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承了 SuperType </span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用字面量添加新方法，会导致上一行代码无效 </span></span><br><span class="line">SubType.prototype = &#123; </span><br><span class="line">    getSubValue : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.subproperty; </span><br><span class="line">    &#125;, </span><br><span class="line"> </span><br><span class="line">    someOtherMethod : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>原型链的问题</li>
</ul>
<p>最主要的问题来自包含引用类型值的原型，这个在前文的“原型模式”中有谈到，这也是为什么要在构造函数中定义属性，而不是在原型对象上定义的原因。</p>
<div  align="center">    
    <img src="/images/photo_6_5_0.png" width='449' height='819'/>
</div>

<div  align="center">    
    <img src="/images/photo_6_5_1.png" width='483' height='478'/>
</div>

<p>原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。</p>
<h3 id="6-3-2-借用构造函数"><a href="#6-3-2-借用构造函数" class="headerlink" title="6.3.2 借用构造函数"></a>6.3.2 借用构造函数</h3><p>在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做<strong>借用构造函数</strong>（constructor stealing）的技术。即在子类型构造函数的内部调用超类型构造函数。（类似于工厂模式那种？）函数只不过是在特定环境中执行代码的对象，因此通过使用 apply()和 call()方法也可以在（将来）新创建的对象上执行构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;   </span><br><span class="line"> <span class="comment">//继承了 SuperType </span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(); </span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>); </span><br><span class="line">alert(instance1.colors);    <span class="comment">//"red,blue,green,black" </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(); </span><br><span class="line">alert(instance2.colors);    <span class="comment">//"red,blue,green"</span></span><br></pre></td></tr></table></figure>
<p>这样一来，就会在新 SubType 对象上执行 SuperType()函数中定义的所有对象初始化代码。结果，SubType 的每个实例就都会具有自己的 colors 属性的副本了。 </p>
<ul>
<li>传递参数</li>
</ul>
<p>借用构造函数有一个很大的优势，即可以在子类型构造函数中<strong>向超类型构造函数传递参数</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;   </span><br><span class="line"> <span class="comment">//继承了 SuperType，同时还传递了参数 </span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>); </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//实例属性 </span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">29</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(); </span><br><span class="line">alert(instance.name);    <span class="comment">//"Nicholas"; </span></span><br><span class="line">alert(instance.age);     <span class="comment">//29</span></span><br></pre></td></tr></table></figure>

<ul>
<li>借用构造函数的问题</li>
</ul>
<p>方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的。所以，借用构造函数的技术也是很少单独使用的。于是就有了下面的组合继承。</p>
<h3 id="6-3-3-组合继承"><a href="#6-3-3-组合继承" class="headerlink" title="6.3.3 组合继承"></a>6.3.3 组合继承</h3><p>组合继承（combination inheritance），指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。（即6.2.4的内容的延伸，所以这6.3的内容和6.2很大关系啊）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name; </span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;   </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//继承属性 </span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name); </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">this</span>.age = age; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//继承方法 </span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line">SubType.prototype.constructor = SubType; </span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="keyword">this</span>.age); </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>); </span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>); </span><br><span class="line">alert(instance1.colors);      <span class="comment">//"red,blue,green,black" </span></span><br><span class="line">instance1.sayName();          <span class="comment">//"Nicholas"; </span></span><br><span class="line">instance1.sayAge();           <span class="comment">//29 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>); </span><br><span class="line">alert(instance2.colors);      <span class="comment">//"red,blue,green" </span></span><br><span class="line">instance2.sayName();          <span class="comment">//"Greg"; </span></span><br><span class="line">instance2.sayAge();           <span class="comment">//27</span></span><br></pre></td></tr></table></figure>
<p>这是<strong>目前JS中最常用</strong>的继承模式。</p>
<h3 id="6-3-4-原型式继承"><a href="#6-3-4-原型式继承" class="headerlink" title="6.3.4 原型式继承"></a>6.3.4 原型式继承</h3><p>道格拉斯·克罗克福德在06年写了篇文章，介绍了JS中的原型式继承。<br>他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125; </span><br><span class="line">    F.prototype = o; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; </span><br><span class="line">    name: <span class="string">"Nicholas"</span>, </span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>] </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person); </span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>; </span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>); </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person); </span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>; </span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>); </span><br><span class="line"> </span><br><span class="line">alert(person.friends);   <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></span><br><span class="line"><span class="comment">// 所以才叫原型式继承嘛</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript 5 通过新增 <strong>Object.create()</strong>方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()与 object()方法的行为相同。<br>不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。 </p>
<h3 id="6-3-5-寄生式继承"><a href="#6-3-5-寄生式继承" class="headerlink" title="6.3.5 寄生式继承"></a>6.3.5 寄生式继承</h3><p>寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推而广之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> clone = object(original);  <span class="comment">//通过调用函数创建一个新对象 </span></span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;      <span class="comment">//以某种方式来增强这个对象 </span></span><br><span class="line">        alert(<span class="string">"hi"</span>); </span><br><span class="line">    &#125;; </span><br><span class="line"> <span class="keyword">return</span> clone; <span class="comment">//返回这个对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以像下面这样来使用 createAnother()函数： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; </span><br><span class="line">    name: <span class="string">"Nicholas"</span>, </span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>] </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person); </span><br><span class="line">anotherPerson.sayHi(); <span class="comment">//"hi"</span></span><br></pre></td></tr></table></figure>
<p>在<strong>主要考虑对象而不是自定义类型和构造函数的情况下</strong>，寄生式继承也是一种有用的模式。</p>
<blockquote>
<p>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。 </p>
</blockquote>
<h3 id="6-3-6-寄生组合式继承"><a href="#6-3-6-寄生组合式继承" class="headerlink" title="6.3.6 寄生组合式继承"></a>6.3.6 寄生组合式继承</h3><p><strong>组合继承最大的问题</strong>就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name; </span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="keyword">this</span>.name); </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;   </span><br><span class="line"> SuperType.call(<span class="keyword">this</span>, name); <span class="comment">//第二次调用 SuperType() </span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">this</span>.age = age; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">//第一次调用 SuperType() </span></span><br><span class="line">SubType.prototype.constructor = SubType; </span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="keyword">this</span>.age); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如图 6-6 所示，有两组 name 和 colors 属性：一组在实例上（实例上的一组会覆盖在原型中的那组，所以才叫组合继承），一组在 SubType 原型中。这就是调用两次 SuperType 构造函数的结果。好在我们已经找到了解决这个问题方法——寄生组合式继承。<br>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype);     <span class="comment">//创建对象 </span></span><br><span class="line"> prototype.constructor = subType; <span class="comment">//增强对象 </span></span><br><span class="line"> subType.prototype = prototype; <span class="comment">//指定对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就可以用调用 inheritPrototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name; </span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="keyword">this</span>.name); </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;   </span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name); </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">this</span>.age = age; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">inheritPrototype(SubType, SuperType); </span><br><span class="line"> </span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="keyword">this</span>.age); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<div  align="center">    
    <img src="/images/photo_6_6.png" width='723' height='853'/>
</div>

<p>这个例子的高效率体现在它只调用了一次 SuperType 构造函数。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
<h2 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4 小结"></a>6.4 小结</h2><p>ECMAScript 支持面向对象（OO）编程，但不使用类或者接口。对象可以在代码执行过程中创建和增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。</p>
<ul>
<li>工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。 </li>
<li>构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。 </li>
<li>原型模式，使用构造函数的 prototype 属性来指定那些应该共享的属性和方法。组合使用构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法</li>
</ul>
<p>JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。<br>此外，还存在下列可供选择的继承模式。 </p>
<ul>
<li>原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。 </li>
<li>寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。 </li>
<li>寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery</title>
    <url>/2020/03/21/JS%E7%9B%B8%E5%85%B3-2020-04-02-jQuery/</url>
    <content><![CDATA[<p>占坑；<br>简介：对jQuery的介绍与学习。</p>
<a id="more"></a>
<p>什么是jQuery：一个JS库<br>什么作用：“Write Less, Do More.”</p>
<ul>
<li>消除浏览器差异</li>
<li>简洁的操作DOM的方法</li>
<li>轻松实现动画、修改CSS等各种操作</li>
</ul>
<p>$是jQuery的别名，jQuery把所有功能都封装在一个全局变量jQuery中，即$。<br>便利：比如操作DOM、处理事件、ajax，不需要考虑浏览器的差异，jQuery会考虑兼容性</p>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><ul>
<li><p>按ID查找</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = $(<span class="string">'#btn'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(span <span class="keyword">instanceof</span> jQuery);</span><br></pre></td></tr></table></figure>
<p>返回的是一个jQuery对象：<br><img src="https://raw.githubusercontent.com/codingbylch/Figure_bed_for_blog/master/img_for_blog/20200402191615.png" alt="jQuery对象"></p>
</li>
<li><p>按tag标签查找：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = $(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.length);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>…略…</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章 - 引用类型</title>
    <url>/2020/03/21/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB-JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-21-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>本章内容 </p>
<ul>
<li>使用对象 </li>
<li>创建并操作数组 </li>
<li>理解基本的 JavaScript 类型 </li>
<li>使用基本类型和基本包装类型 </li>
</ul>
<p>引用类型的值（即对象）是<strong>引用类型</strong>的一个实例。在 ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。引用类型有时候也被称为<strong>对象定义</strong>，因为它们描述的是一类对象所具有的属性和方法。被称为类并不妥当，因为它不具备传统的面向对象语言所支持的类和接口等基本结构。<br>新对象是使用 new 操作符后跟一个<strong>构造函数</strong>来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p>这行代码创建了 Object 引用类型的一个新实例，然后把该实例保存在了变量 person 中。</p>
<h2 id="5-1-Object-类型"><a href="#5-1-Object-类型" class="headerlink" title="5.1 Object 类型"></a>5.1 Object 类型</h2><p><strong>创建 Object 实例</strong>的方式有两种。<br>第一种是使用 new 操作符后跟 Object 构造函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">person.name = <span class="string">"Nicholas"</span>; </span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
<p>另一种方式是使用对象字面量表示法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; </span><br><span class="line">    name : <span class="string">"Nicholas"</span>, </span><br><span class="line">    age : <span class="number">29</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在使用对象字面量语法时，属性名也可以使用字符串。</p>
<blockquote>
<p>在通过对象字面量定义对象时，实际上不会调用 Object 构造函数。</p>
</blockquote>
<p>际上，对象字面量是向函数传递大量可选参数的首选方式，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayInfo</span>(<span class="params">args</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> output = <span class="string">""</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> args.name == <span class="string">"string"</span>)&#123; </span><br><span class="line">        output += <span class="string">"Name: "</span> + args.name + <span class="string">"\n"</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> args.age == <span class="string">"number"</span>) &#123; </span><br><span class="line">        output += <span class="string">"Age: "</span> + args.age + <span class="string">"\n"</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    alert(output); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">displayInfo(&#123;  </span><br><span class="line">    name: <span class="string">"Nicholas"</span>,  </span><br><span class="line">    age: <span class="number">29</span> </span><br><span class="line">&#125;); </span><br><span class="line"> </span><br><span class="line">displayInfo(&#123; </span><br><span class="line">    name: <span class="string">"Greg"</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>函数 displayInfo()接受一个名为 args的参数。这个参数可能带有一个名为 name或 age 的属性，也可能这两个属性都有或者都没有。</p>
<blockquote>
<p>这种传递参数的模式最适合需要向函数传入大量可选参数的情形。最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。<br><strong>访问对象属性</strong>时可使用点表示法，也可以使用方括号表示法。<br>通常，除非必须使用变量来访问属性，否则我们建议使用点表示法。 </p>
</blockquote>
<h2 id="5-2-Array-类型"><a href="#5-2-Array-类型" class="headerlink" title="5.2 Array 类型"></a>5.2 Array 类型</h2><p>与其他语言不同的是，ECMAScript 数组的每一项可以保存任何类型的数据。而且，ECMAScript 数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。（可从对象的角度来理解）<br><strong>创建数组</strong>的基本方式有两种。第一种是使用 Array 构造函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(); </span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// 创建一个包含 3 项的数组 </span></span><br><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Greg"</span>); <span class="comment">// 创建一个包含 1 项，即字符串"Greg"的数组</span></span><br></pre></td></tr></table></figure>
<p>另外，在使用 Array 构造函数时也可以省略 new 操作符。<br>第二种基本方式是使用数组字面量表示法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组 </span></span><br><span class="line"><span class="keyword">var</span> names = []; <span class="comment">// 创建一个空数组</span></span><br></pre></td></tr></table></figure>
<p>在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引。（因为用点访问属性为数字实在是太奇怪了啊）<br>数组的<strong>length 属性</strong>的值为数组中最大索引值+1（数组最后一项的索引始终是 length-1）；而且通过设置可以从数组的末尾移除项或向数组中添加新项。</p>
<h3 id="5-2-1-检测数组"><a href="#5-2-1-检测数组" class="headerlink" title="5.2.1 检测数组"></a>5.2.1 检测数组</h3><p>对于一个网页，或者一个全局作用域而言，使用 <strong>instanceof</strong> 操作符即可，但如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。<br>为了解决这个问题，ECMAScript 5 新增了 <strong>Array.isArray()</strong>方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value))&#123; </span><br><span class="line">    <span class="comment">//对数组执行某些操作 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-2-转换方法"><a href="#5-2-2-转换方法" class="headerlink" title="5.2.2 转换方法"></a>5.2.2 转换方法</h3><p>如前所述，所有对象都具有 toLocaleString()、toString()和 valueOf()方法。其中，调用数组的 <strong>toString()方法</strong>会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用 <strong>valueOf()</strong>返回的还是数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">colors.toString(); <span class="comment">// "red,blue,green"</span></span><br><span class="line">colors.valueOf(); <span class="comment">// ["red", "blue", "green"]</span></span><br><span class="line">colors; <span class="comment">// ["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure>
<p>而如果使用 <strong>join()方法</strong>，则可以使用不同的分隔符来构建这个字符串（不传默认使用逗号分隔）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(colors.join(<span class="string">","</span>));       <span class="comment">// "red,green,blue" </span></span><br><span class="line"><span class="built_in">console</span>.log(colors.join(<span class="string">"||"</span>));      <span class="comment">// "red||green||blue"</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-3-栈方法"><a href="#5-2-3-栈方法" class="headerlink" title="5.2.3 栈方法"></a>5.2.3 栈方法</h3><p>ECMAScript 为数组专门提供了 <strong>push()</strong>和 <strong>pop()</strong>方法，以便实现类似栈的行为。<br>push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。<br>pop()方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。</p>
<h3 id="5-2-4-队列方法"><a href="#5-2-4-队列方法" class="headerlink" title="5.2.4 队列方法"></a>5.2.4 队列方法</h3><p>队列数据结构的访问规则是 FIFO（First-In-First-Out，先进先出）。弹出第一项并返回的方法为<strong>shift()</strong>，再结合<strong>push()</strong>方法。<br>ECMAScript 还为数组提供了一个 <strong>unshift()</strong>方法：能在数组前端添加任意个项并返回新数组的长度。同时<strong>使用 unshift()和 pop()</strong>方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项。</p>
<h3 id="5-2-5-重排序方法"><a href="#5-2-5-重排序方法" class="headerlink" title="5.2.5 重排序方法"></a>5.2.5 重排序方法</h3><p>数组中已经存在两个可以直接用来重排序的方法：<strong>reverse()和 sort()</strong>。</p>
<ul>
<li>sort()方法：<br>默认按升序排列数组项。为了实现排序，sort()方法会<strong>调用每个数组项的 toString()</strong>转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。<br>sort()方法可以接收一个<strong>比较函数</strong>作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//看负数在哪，顺序就在哪</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.sort(compare); </span><br><span class="line">alert(values); <span class="comment">//0,1,5,10,15</span></span><br></pre></td></tr></table></figure>
对于数值类型或者其 valueOf()方法会返回数值类型的对象类型，可使用更简单的比较函数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> value2 - value1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-2-6-操作方法"><a href="#5-2-6-操作方法" class="headerlink" title="5.2.6 操作方法"></a>5.2.6 操作方法</h3><p><strong>concat()</strong>方法可以基于当前数组中的所有项创建一个新数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>]; </span><br><span class="line"><span class="keyword">var</span> colors2 = colors.concat(<span class="string">"yellow"</span>, [<span class="string">"black"</span>, <span class="string">"brown"</span>]); </span><br><span class="line"> </span><br><span class="line">alert(colors);     <span class="comment">//red,green,blue         </span></span><br><span class="line">alert(colors2);    <span class="comment">//red,green,blue,yellow,black,brown</span></span><br></pre></td></tr></table></figure>

<p><strong>slice()</strong>方法它能够基于当前数组中的一或多个项创建一个新数组，slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>]; </span><br><span class="line"><span class="keyword">var</span> colors2 = colors.slice(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">var</span> colors3 = colors.slice(<span class="number">1</span>,<span class="number">4</span>); </span><br><span class="line"> </span><br><span class="line">alert(colors2);   <span class="comment">//green,blue,yellow,purple </span></span><br><span class="line">alert(colors3);   <span class="comment">//green,blue,yellow</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果 slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。如果结束位置小于起始位置，则返回空数组。</p>
</blockquote>
<p><strong>splice()</strong>方法比较强大（会修改原数组），始终都会返回一个数组，该数组中包含从原始数组中删除的项。使用方式有三种：</p>
<ul>
<li>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。</li>
<li>可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数）和要插入的项。</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。</li>
</ul>
<h3 id="5-2-7-位置方法"><a href="#5-2-7-位置方法" class="headerlink" title="5.2.7 位置方法"></a>5.2.7 位置方法</h3><p>两个位置方法：<strong>indexOf()</strong>和<strong>lastIndexOf()</strong>。这两个方法都接收两个参数：要查找的项和表示查找起点位置的索引（可选）。其中，indexOf()方法从数组的开头（位置 0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。 </p>
<h3 id="5-2-8-迭代方法"><a href="#5-2-8-迭代方法" class="headerlink" title="5.2.8 迭代方法"></a>5.2.8 迭代方法</h3><p>定义了 5 个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响 this 的值。传入方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。给出5个迭代方法的作用：</p>
<ul>
<li>every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。</li>
<li>filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。（用于过滤） </li>
<li>forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。（类似for循环迭代数组） </li>
<li>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 </li>
<li>some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。</li>
</ul>
<p>以上方法都不会修改数组中的包含的值。 </p>
<h3 id="5-2-9-归并方法"><a href="#5-2-9-归并方法" class="headerlink" title="5.2.9 归并方法"></a>5.2.9 归并方法</h3><p>ECMAScript 5 还新增了两个归并数组的方法：<strong>reduce()</strong>和 <strong>reduceRight()</strong>。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。 （区别取决于要从哪头开始遍历数组）<br>reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; </span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> prev + cur;  </span><br><span class="line">&#125;); </span><br><span class="line">alert(sum); <span class="comment">//15</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3-Date-类型"><a href="#5-3-Date-类型" class="headerlink" title="5.3 Date 类型"></a>5.3 Date 类型</h2><p>ECMAScript 中的 Date 类型是在早期 Java 中的 java.util.Date 类基础上构建的。<br>要创建一个日期对象，使用 new 操作符和 Date 构造函数即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure>
<p>ECMAScript 提供了两个方法：Date.parse()和 Date.UTC()。<br><strong>Date.parse()</strong>方法接收一个表示日期的字符串参数（“月/日/年”，如 6/13/2004； ），然后尝试根据这个字符串返回相应日期的毫秒数。实际上，如果直接将表示日期的字符串传递给 Date 构造函数，也会在后台调用 Date.parse()：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">"May 25, 2004"</span>));</span><br><span class="line"><span class="comment">// 即 </span></span><br><span class="line"><span class="keyword">var</span>  someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"May 25, 2004"</span>);</span><br></pre></td></tr></table></figure>
<p>使用 <strong>Date.UTC()</strong>方法的例子： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GMT 时间 2000 年 1 月 1 日午夜零时 </span></span><br><span class="line"><span class="keyword">var</span> y2k = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2000</span>, <span class="number">0</span>)); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// GMT 时间 2005 年 5 月 5 日下午 5:55:55 </span></span><br><span class="line"><span class="keyword">var</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// Date 构造函数也会模仿 Date.UTC()</span></span><br><span class="line"><span class="comment">// 本地时间 2000 年 1 月 1 日午夜零时 </span></span><br><span class="line"><span class="keyword">var</span> y2k = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>ECMAScript 5 添加了 Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。<br>例如我们可以取得开始到结束所经过的时间：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取得开始时间 </span></span><br><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">//调用函数 </span></span><br><span class="line">doSomething(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">//取得停止时间 </span></span><br><span class="line"><span class="keyword">var</span> stop = <span class="built_in">Date</span>.now(), </span><br><span class="line">     result = stop – start;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-1-继承的方法"><a href="#5-3-1-继承的方法" class="headerlink" title="5.3.1 继承的方法"></a>5.3.1 继承的方法</h3><p>与其他引用类型一样，Date 类型也重写了 toLocaleString()、toString()和 valueOf()方法；<br>Date 类型的 toLocaleString()方法会按照与<strong>浏览器设置</strong>的地区相适应的格式返回日期和时间：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">c = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() <span class="comment">// "2020/3/21 下午12:07:13"</span></span><br></pre></td></tr></table></figure>
<p>toString()方法则通常返回带有时区信息的日期和时间：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">c = <span class="keyword">new</span> <span class="built_in">Date</span>().toString() <span class="comment">// "Sat Mar 21 2020 12:08:31 GMT+0800 (中国标准时间)"</span></span><br></pre></td></tr></table></figure>
<p>valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示：</p>
<h3 id="5-3-2-日期格式化方法"><a href="#5-3-2-日期格式化方法" class="headerlink" title="5.3.2 日期格式化方法"></a>5.3.2 日期格式化方法</h3><p>Date 类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。 </p>
<ul>
<li>toDateString()——以特定于实现的格式显示星期几、月、日和年； </li>
<li>toTimeString()——以特定于实现的格式显示时、分、秒和时区； </li>
<li>toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年； </li>
<li>toLocaleTimeString()——以特定于实现的格式显示时、分、秒； </li>
<li>toUTCString()——以特定于实现的格式完整的 UTC 日期。</li>
</ul>
<h3 id="5-3-3-日期-时间组件方法"><a href="#5-3-3-日期-时间组件方法" class="headerlink" title="5.3.3 日期/时间组件方法"></a>5.3.3 日期/时间组件方法</h3><p>Date 类型的方法如下表所示（部分）：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getTime()</td>
<td>返回表示日期的毫秒数；与valueOf()方法返回的值相同</td>
</tr>
<tr>
<td>setTime(毫秒)</td>
<td>以毫秒数设置日期，会改变整个日期</td>
</tr>
<tr>
<td>getFullYear()</td>
<td>取得4位数的年份（如2007而非仅07）</td>
</tr>
</tbody></table>
<h2 id="5-4-RegExp-类型"><a href="#5-4-RegExp-类型" class="headerlink" title="5.4 RegExp 类型"></a>5.4 RegExp 类型</h2><p>ECMAScript 通过 RegExp 类型来支持<strong>正则表达式</strong>。使用下面类似 Perl 的语法，就可以创建一个正则表达式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags ;</span><br></pre></td></tr></table></figure>
<p>（待续）</p>
<h2 id="5-5-Function-类型"><a href="#5-5-Function-类型" class="headerlink" title="5.5 Function 类型"></a>5.5 Function 类型</h2><p>ECMAScript 中什么最有意思，我想那莫过于函数了：<strong>函数是对象</strong>。每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。<br>由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个名字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125; </span><br><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));        <span class="comment">//20 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> anotherSum = sum; </span><br><span class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20 </span></span><br><span class="line"> </span><br><span class="line">sum = <span class="literal">null</span>; </span><br><span class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<h3 id="5-5-1-没有重载（深入理解）"><a href="#5-5-1-没有重载（深入理解）" class="headerlink" title="5.5.1 没有重载（深入理解）"></a>5.5.1 没有重载（深入理解）</h3><p>将函数名想象为指针，也有助于理解为什么 ECMAScript 中没有函数重载的概念。</p>
<h3 id="5-5-2-函数声明与函数表达式"><a href="#5-5-2-函数声明与函数表达式" class="headerlink" title="5.5.2 函数声明与函数表达式"></a>5.5.2 函数声明与函数表达式</h3><p>解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）（<strong>函数声明提升（function declaration hoisting）</strong>）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>)); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-3-作为值的函数"><a href="#5-5-3-作为值的函数" class="headerlink" title="5.5.3 作为值的函数"></a>5.5.3 作为值的函数</h3><p>因为 ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> someFunction(someArgument); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 callSomeFunction()函数是通用的，即无论第一个参数中传递进来的是什么函数，它都会返回执行第一个参数后的结果。<strong>要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。</strong><br>当然，可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术，比如我们想要根据某个对象属性对数组进行排序而设计的比较函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 这里的object1\2哪来的，看看sort对比较函数的定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span>&#123; </span><br><span class="line">        <span class="keyword">var</span> value1 = object1[propertyName]; </span><br><span class="line">        <span class="keyword">var</span> value2 = object2[propertyName]; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2)&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data = [&#123;<span class="attr">name</span>: <span class="string">"Zachary"</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"Nicholas"</span>, <span class="attr">age</span>: <span class="number">29</span>&#125;]; </span><br><span class="line"> </span><br><span class="line">data.sort(createComparisonFunction(<span class="string">"name"</span>)); </span><br><span class="line">alert(data[<span class="number">0</span>].name);  <span class="comment">//Nicholas </span></span><br><span class="line"> </span><br><span class="line">data.sort(createComparisonFunction(<span class="string">"age"</span>)); </span><br><span class="line">alert(data[<span class="number">0</span>].name);  <span class="comment">//Zachary</span></span><br></pre></td></tr></table></figure>

<h3 id="5-5-4-函数内部属性"><a href="#5-5-4-函数内部属性" class="headerlink" title="5.5.4 函数内部属性"></a>5.5.4 函数内部属性</h3><p>在函数内部，有两个特殊的对象：<strong>arguments</strong> 和 <strong>this</strong>。虽然 arguments 的主要用途是保存函数参数，但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。于是递归函数中的函数名可以用arguments.callee表示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数内部的另一个特殊对象是 this，其行为与 Java 和 C#中的 this 大致类似。this引用的是函数据以执行的环境对象，来看例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>; </span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="keyword">this</span>.color); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">sayColor();     <span class="comment">//"red" </span></span><br><span class="line"> </span><br><span class="line">o.sayColor = sayColor; </span><br><span class="line">o.sayColor();   <span class="comment">//"blue"</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript 5 也规范化了另一个函数对象的属性：caller。这个属性中<strong>保存着调用当前函数的函数的引用</strong>，如果是在全局作用域中调用当前函数，它的值为 null。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    inner();  </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(inner.caller); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">outer(); <span class="comment">// 输出outer()函数的源码</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当函数在严格模式下运行时，访问 arguments.callee 会导致错误。arguments.caller 属性在严格模式下访问它也会导致错误。这是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。</p>
</blockquote>
<h3 id="5-5-5-函数属性和方法"><a href="#5-5-5-函数属性和方法" class="headerlink" title="5.5.5 函数属性和方法"></a>5.5.5 函数属性和方法</h3><p>函数是对象，因此也有属性和方法。每个函数都包含两个属性：length 和 prototype。<br><strong>length</strong> 属性表示函数希望接收的命名参数的个数。<br><strong>prototype</strong> 属性保存所有实例方法。在 ECMAScript 5 中，prototype 属性是不可枚举的，因此使用 for-in 无法发现。 </p>
<p>每个函数都包含两个非继承而来的方法：<strong>apply()</strong>和 <strong>call()</strong>。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。<br>首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是arguments 对象。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>)</span>&#123; </span><br><span class="line"> <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 传入 arguments 对象 </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, [num1, num2]);    <span class="comment">// 传入数组 </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">alert(callSum1(<span class="number">10</span>,<span class="number">10</span>));   <span class="comment">//20 </span></span><br><span class="line">alert(callSum2(<span class="number">10</span>,<span class="number">10</span>));   <span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p><strong>callSum1()</strong>在执行 sum()函数时传入了 this 作为 this 值（因为是<strong>在全局作用域中调用</strong>的，所以传入的就是 window 对象）。<br><strong>call()</strong>方法与 apply()方法的<strong>作用相同</strong>，它们的区别仅在于接收参数的方式不同：第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。在使用call()方法时，传递给函数的参数<strong>必须逐个列举出来</strong>，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> sum.call(<span class="keyword">this</span>, num1, num2); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">alert(callSum(<span class="number">10</span>,<span class="number">10</span>));   <span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>它们真正强大的地方是能够<strong>扩充函数赖以运行的作用域</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>; </span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="keyword">this</span>.color); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">sayColor();                <span class="comment">//red </span></span><br><span class="line"> </span><br><span class="line">sayColor.call(<span class="keyword">this</span>);       <span class="comment">//red </span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>);     <span class="comment">//red </span></span><br><span class="line">sayColor.call(o);          <span class="comment">//blue</span></span><br></pre></td></tr></table></figure>
<p>当运行 sayColor.call(o)时，函数的执行环境就不一样了，因为此时函数体内的 this 对象指向了 o，于是结果显示的是”blue”。<br>使用 call()（或 apply()）来扩充作用域的<strong>最大好处</strong>，就是对象不需要与方法有任何耦合关系。（对比前文5.5.4的例子，需要将sayColor()放入o对象里；而这里使用了call/apply就比较方便了）</p>
<p>ECMAScript 5 还定义了一个方法：<strong>bind()</strong>。这个方法会创建一个函数的实例，其 this 值会被绑定到传给 bind()函数的值。例如： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>; </span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;; </span><br><span class="line"><span class="keyword">var</span> h = &#123;<span class="attr">color</span>:<span class="string">'yellow'</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o); </span><br><span class="line">objectSayColor();    <span class="comment">// blue</span></span><br><span class="line"><span class="keyword">var</span> h_say_color = sayColor.bind(h);</span><br><span class="line">h_say_color(); <span class="comment">// yellow</span></span><br></pre></td></tr></table></figure>

<h2 id="5-6-基本包装类型"><a href="#5-6-基本包装类型" class="headerlink" title="5.6 基本包装类型"></a>5.6 基本包装类型</h2><p>为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型：<strong>Boolean</strong>、<strong>Number</strong> 和<strong>String</strong>。<strong>实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象</strong>，从而让我们能够调用一些方法来操作这些数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>; </span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法。其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理：</p>
<ul>
<li>(1) 创建 String 类型的一个实例； </li>
<li>(2) 在实例上调用指定的方法； </li>
<li>(3) 销毁这个实例。 </li>
</ul>
<p>可以将以上三个步骤想象成是执行了下列 ECMAScript 代码。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"some text"</span>); </span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>); </span><br><span class="line">s1 =  <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于 Boolean和 Number 类型对应的布尔值和数字值。 （所以叫“包装类型”吗:)）</p>
<p>引用类型与基本包装类型的主要区别就是<strong>对象的生存期</strong>。使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。意味着<strong>基本类型值不能添加属性和方法</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>; </span><br><span class="line">s1.color = <span class="string">"red"</span>; </span><br><span class="line">alert(s1.color); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>对基本包装类型的实例调用 typeof 会返回”object”，而且所有基本包装类型的对在布尔表达式中都会被转换为布尔值 true（包括falseObject）。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'ddadad'</span></span><br><span class="line"><span class="keyword">typeof</span> a <span class="comment">// "string"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bb = <span class="keyword">new</span> <span class="built_in">String</span>()</span><br><span class="line"><span class="keyword">typeof</span> bb <span class="comment">// "object"</span></span><br><span class="line"><span class="comment">// Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"some text"</span>); </span><br><span class="line">alert(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>要注意的是，使用 new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>; </span><br><span class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value);  <span class="comment">//转型函数 </span></span><br><span class="line">alert(<span class="keyword">typeof</span> number);        <span class="comment">//"number" </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">//构造函数 </span></span><br><span class="line">alert(<span class="keyword">typeof</span> obj);           <span class="comment">//"object"</span></span><br></pre></td></tr></table></figure>

<h3 id="5-6-1-Boolean类型"><a href="#5-6-1-Boolean类型" class="headerlink" title="5.6.1 Boolean类型"></a>5.6.1 Boolean类型</h3><p>Boolean 对象在 ECMAScript 中的用处不大，因为它经常会造成人们的误解。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>); </span><br><span class="line"><span class="keyword">var</span> result = falseObject &amp;&amp; <span class="literal">true</span>; </span><br><span class="line">alert(result);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>基本类型与引用类型的布尔值还有两个区别：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="keyword">typeof</span> falseObject);   <span class="comment">//object </span></span><br><span class="line">alert(<span class="keyword">typeof</span> falseValue);    <span class="comment">//boolean </span></span><br><span class="line">alert(falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//true </span></span><br><span class="line">alert(falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>理解区别但永远不要使用Boolean对象（所以这是谁拍脑门子规定的???）</p>
<h3 id="5-6-2-Number类型"><a href="#5-6-2-Number类型" class="headerlink" title="5.6.2 Number类型"></a>5.6.2 Number类型</h3><p>创建 Number 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>); </span><br><span class="line"><span class="comment">// 实际上不建议直接实例化Number对象，原因与显式创建 Boolean 对象一样</span></span><br><span class="line"><span class="comment">// var a = 10 它不香吗???</span></span><br></pre></td></tr></table></figure>
<p>Number 类型也重写了 valueOf()、toLocaleString()和 toString()方法。 valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式。<br>除了继承的方法，Number 类型还提供了一些用于将数值格式化为字符串的方法，都有有<strong>自动舍入</strong>的特性：</p>
<ul>
<li><p>toFixed()方法会按照指定的小数位返回数值的字符串表示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>; </span><br><span class="line">alert(num.toFixed(<span class="number">2</span>));     <span class="comment">//"10.00"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>toExponential()方法返回以指数表示法（也称 e 表示法）表示的数值的字符串形式。也接收一个参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>; </span><br><span class="line">alert(num.toExponential(<span class="number">1</span>)); <span class="comment">//"1.0e+1"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>toPrecision()方法会返回某个数值的最合适的格式，这个方法接收一个参数，即表示数值的所有数字的位数（不包括指数部分）。</p>
</li>
</ul>
<h3 id="5-6-3-String类型"><a href="#5-6-3-String类型" class="headerlink" title="5.6.3 String类型"></a>5.6.3 String类型</h3><p>继承的 valueOf()、toLocaleString()和 toString()方法，都返回对象所表示的基本字符串值。<br>String 类型的每个实例都有一个 length 属性，表示字符串中包含多个字符。<br>String 类型提供了很多方法，用于辅助完成对 ECMAScript 中字符串的解析和操作。</p>
<ul>
<li><p>字符方法<br>两个用于访问字符串中特定字符的方法是：charAt()和 charCodeAt()：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>; </span><br><span class="line">alert(stringValue.charAt(<span class="number">1</span>));   <span class="comment">//"e" </span></span><br><span class="line">alert(stringValue.charCodeAt(<span class="number">1</span>));   <span class="comment">//输出"101" </span></span><br><span class="line">alert(stringValue[<span class="number">1</span>]);   <span class="comment">//"e"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串操作方法<br>concat()，用于将一或多个字符串拼接起来，返回拼接得到的新字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello "</span>; </span><br><span class="line"><span class="keyword">var</span> result = stringValue.concat(<span class="string">"world"</span>); </span><br><span class="line">alert(result); <span class="comment">//"hello world"</span></span><br></pre></td></tr></table></figure>
<p>但实践中使用更多的还是<strong>加号操作符（+）</strong>。<br>slice()、substr()和 substring()都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>; </span><br><span class="line">alert(stringValue.slice(<span class="number">3</span>)); <span class="comment">//"lo world" </span></span><br><span class="line">alert(stringValue.substring(<span class="number">3</span>)); <span class="comment">//"lo world" </span></span><br><span class="line">alert(stringValue.substr(<span class="number">3</span>)); <span class="comment">//"lo world" </span></span><br><span class="line">alert(stringValue.slice(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">//"lo w" </span></span><br><span class="line">alert(stringValue.substring(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">//"lo w" </span></span><br><span class="line">alert(stringValue.substr(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">//"lo worl"</span></span><br></pre></td></tr></table></figure>
<p>传递负值时行为各不相同，这里不介绍了。（感觉用不到）</p>
</li>
<li><p>字符串位置方法<br>indexOf()和 lastIndexOf()这两个方法都是从一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回-1）。两者区别就是一前一后的区别。<br>这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。</p>
</li>
<li><p>trim()方法<br>ECMAScript 5 为所有字符串定义了 trim()方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"   hello world   "</span>; </span><br><span class="line"><span class="keyword">var</span> trimmedStringValue = stringValue.trim(); </span><br><span class="line">alert(stringValue);            <span class="comment">//"   hello world   " </span></span><br><span class="line">alert(trimmedStringValue);     <span class="comment">//"hello world"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串大小写转换方法<br>toLowerCase()和 toUpperCase()</p>
</li>
<li><p>字符串的模式匹配方法</p>
</li>
</ul>
<p><strong>match()</strong>只接受一个参数，要么是一个正则表达式，要么是一个 RegExp 对象。本质上与调用 RegExp 的 exec()方法相同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;  </span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/.at/</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//与 pattern.exec(text)相同 </span></span><br><span class="line"><span class="keyword">var</span> matches = text.match(pattern);         </span><br><span class="line">alert(matches.index); <span class="comment">//0 </span></span><br><span class="line">alert(matches[<span class="number">0</span>]); <span class="comment">//"cat" </span></span><br><span class="line">alert(pattern.lastIndex); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>另一个用于查找模式的方法是<strong>search()</strong>。这个方法的唯一参数与 match()方法的参数相同：由字符串或 RegExp 对象指定的一个正则表达式。search()方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1。而且，search()方法始终是从字符串开头向后查找模式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;  </span><br><span class="line"><span class="keyword">var</span> pos = text.search(<span class="regexp">/at/</span>); </span><br><span class="line">alert(pos);   <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>替换子字符串的操作，ECMAScript 提供了 <strong>replace()</strong>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;  </span><br><span class="line"><span class="keyword">var</span> result = text.replace(<span class="string">"at"</span>, <span class="string">"ond"</span>); </span><br><span class="line">alert(result);    <span class="comment">//"cond, bat, sat, fat" </span></span><br><span class="line"> </span><br><span class="line">result = text.replace(<span class="regexp">/at/g</span>, <span class="string">"ond"</span>); </span><br><span class="line">alert(result);    <span class="comment">//"cond, bond, sond, fond"</span></span><br></pre></td></tr></table></figure>
<p>最后一个与模式匹配有关的方法是 <strong>split()</strong>，这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。split()方法可以接受可选的第二个参数，用于指定数组的大小：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colorText = <span class="string">"red,blue,green,yellow"</span>; </span><br><span class="line"><span class="keyword">var</span> colors1 = colorText.split(<span class="string">","</span>);          <span class="comment">//["red", "blue", "green", "yellow"] </span></span><br><span class="line"><span class="keyword">var</span> colors2 = colorText.split(<span class="string">","</span>, <span class="number">2</span>);       <span class="comment">//["red", "blue"] </span></span><br><span class="line"><span class="keyword">var</span> colors3 = colorText.split(<span class="regexp">/[^\,]+/</span>);     <span class="comment">//["", ",", ",", ",", ""]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>localeCompare()方法<br>localeCompare()，这个方法比较两个字符串，并返回下列值中的一个：<ul>
<li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）； </li>
<li>如果字符串等于字符串参数，则返回 0； </li>
<li>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是 1，具体的值同样要视实现而定）。 </li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"yellow"</span>;        </span><br><span class="line">alert(stringValue.localeCompare(<span class="string">"brick"</span>));      <span class="comment">//1 </span></span><br><span class="line">alert(stringValue.localeCompare(<span class="string">"yellow"</span>));      <span class="comment">//0 </span></span><br><span class="line">alert(stringValue.localeCompare(<span class="string">"zoo"</span>));         <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>fromCharCode()方法<br>fromCharCode()。这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。与实例方法 charCodeAt()相反：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="built_in">String</span>.fromCharCode(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>)); <span class="comment">//"hello"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTML 方法<br>早期方法，尽量不使用。</p>
</li>
</ul>
<h2 id="5-7-单体内置对象"><a href="#5-7-单体内置对象" class="headerlink" title="5.7 单体内置对象"></a>5.7 单体内置对象</h2><p>ECMA-262 对内置对象的定义是：“由 ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了。”<br>除了前面所介绍的Object、Array 和 String，还定义了两个单体内置对象：Global 和 Math。</p>
<h3 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h3><p>在某种意义上是作为一个终极的“兜底儿对象”：不属于任何其他对象的属性和方法，最终都是它的属性和方法。所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。</p>
<ul>
<li><p>URI 编码方法<br>Global 对象的 <strong>encodeURI()</strong>和 <strong>encodeURIComponent()</strong>方法可以对 URI（Uniform Resource Identifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的 URI 中不能包含某些字符,所以通过编码之后浏览器就能识别了。<br>两者编码的<strong>区别</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uri = <span class="string">"http://www.wrox.com/illegal value.htm#start"</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//"http://www.wrox.com/illegal%20value.htm#start" </span></span><br><span class="line">alert(<span class="built_in">encodeURI</span>(uri)); </span><br><span class="line"> </span><br><span class="line"><span class="comment">//"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start" </span></span><br><span class="line">alert(<span class="built_in">encodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure>
<p>使用 encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20。而 encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。这也正是可以对整个 URI 使用 encodeURI()，而只能对附加在现有 URI 后面的字符串使用encodeURIComponent()的原因所在。<br>与 encodeURI()和 encodeURIComponent()方法对应的两个方法分别是decodeURI()和decodeURIComponent()。不能混用。</p>
</li>
<li><p>eval()方法<br>eval()方法就像是一个完整的 ECMAScript 解析器，它只接受一个参数，即要执行的 ECMAScript（或 JavaScript）字符串。通过 eval()执行的代码被认为是包含该次调用的执行环境的一部分，意味着通过 eval()执行的代码可以引用在包含环境中定义的变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">"hello world"</span>; </span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"alert(msg)"</span>);    <span class="comment">//"hello world"</span></span><br></pre></td></tr></table></figure>
<p>在 eval()中创建的任何变量或函数都不会被提升。严格模式下，在外部访问不到 eval()中创建的任何变量或函数。</p>
<blockquote>
<p>能够解释代码字符串的能力非常强大，但也非常危险。防范<strong>代码注入</strong>。</p>
</blockquote>
</li>
<li><p>Global 对象的属性<br>略。</p>
</li>
<li><p>window 对象<br>ECMAScript 虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为window 对象的一部分加以实现的。于是全局变量或函数都是window对象的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"red"</span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="built_in">window</span>.color); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="built_in">window</span>.sayColor();  <span class="comment">//"red"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-7-2-Math对象"><a href="#5-7-2-Math对象" class="headerlink" title="5.7.2 Math对象"></a>5.7.2 Math对象</h3><ul>
<li>Math 对象的属性 </li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Math.E</td>
<td>自然对数的底数，即常量e的值</td>
</tr>
<tr>
<td>Math.LN10</td>
<td>10的自然对数</td>
</tr>
<tr>
<td>Math.LN2</td>
<td>2的自然对数</td>
</tr>
<tr>
<td>Math.LOG2E</td>
<td>以2为底e的对数</td>
</tr>
<tr>
<td>Math.LOG10E</td>
<td>以10为底e的对数</td>
</tr>
<tr>
<td>Math.PI</td>
<td>π的值</td>
</tr>
<tr>
<td>Math.SQRT1_2</td>
<td>1/2的平方根（即2的平方根的倒数）</td>
</tr>
<tr>
<td>Math.SQRT2</td>
<td>2的平方根</td>
</tr>
</tbody></table>
<ul>
<li><p>min()和 max()方法<br>找最大最小值，两个方法都可以接收<strong>任意多</strong>个数值参数。这两个方法经常用于避免多余的循环和在 if 语句中确定一组数的最大值。<br>要找到数组中的最大或最小值，可这样使用 apply()方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]; </span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values);</span><br></pre></td></tr></table></figure>
</li>
<li><p>舍入方法<br>小数值舍入为整数的几个方法：Math.ceil()、Math.floor()和 Math.round()。<br>遵循下列舍入规则： </p>
</li>
<li><p>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数； </p>
</li>
<li><p>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数； </p>
</li>
<li><p>Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数（这也是我们在数学课上学到的舍入规则）。 </p>
</li>
<li><p>random()方法<br>Math.random()方法返回大于等于 0 小于 1 的一个随机数。<br>利用 Math.random()从某个整数范围内随机选择一个值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">值 =  <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * 可能值的总数 + 第一个可能的值) </span><br><span class="line"><span class="comment">// 如2 - 10</span></span><br><span class="line"><span class="keyword">var</span>  num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">9</span> + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Math.abs(num)</td>
<td>返回num的绝对值</td>
<td>Math.asin(x)</td>
<td>返回x的反正弦值</td>
</tr>
<tr>
<td>Math.exp(num)</td>
<td>返回Math.E的num次幂</td>
<td>Math.atan(x)</td>
<td>返回x的反正切值</td>
</tr>
<tr>
<td>Math.log(num)</td>
<td>返回num的自然对数</td>
<td>Math.atan2(y,x)</td>
<td>返回y/x的反正切值</td>
</tr>
<tr>
<td>Math.pow(num,power)</td>
<td>返回num的power次幂</td>
<td>Math.cos(x)</td>
<td>返回x的余弦值</td>
</tr>
<tr>
<td>Math.sqrt(num)</td>
<td>返回num的平方根</td>
<td>Math.sin(x)</td>
<td>返回x的正弦值</td>
</tr>
<tr>
<td>Math.acos(x)</td>
<td>返回x的反余弦值</td>
<td>Math.tan(x)</td>
<td>返回x的正切值</td>
</tr>
</tbody></table>
<h2 id="5-8-小结"><a href="#5-8-小结" class="headerlink" title="5.8 小结"></a>5.8 小结</h2><p>对象在 JavaScript 中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象。简要总结：</p>
<ul>
<li>引用类型与传统面向对象程序设计中的类相似，但实现不同； </li>
<li>Object 是一个基础类型，其他所有类型都从 Object 继承了基本的行为； </li>
<li>Array 类型是一组值的有序列表，同时还提供了操作和转换这些值的功能； </li>
<li>Date 类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能； </li>
<li>RegExp 类型是 ECMAScript 支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式功能。 </li>
</ul>
<p>函数实际上是 Function 类型的实例，因此函数也是对象，所以函数也拥有方法。<br>三种基本包装类型分别是：Boolean、Number 和 String，所以 JavaScript 中的基本类型值可以被当作对象来访问。共同的特征： </p>
<ul>
<li>每个包装类型都映射到同名的基本类型； </li>
<li>在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据<br>操作； </li>
<li>操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。</li>
</ul>
<p>Web 浏览器实现了承担Global的 window 对象。<br>Math 对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务。 </p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章 - 变量、作用域和内存问题</title>
    <url>/2020/03/20/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB-JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-20-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>本章内容 </p>
<ul>
<li>理解基本类型和引用类型的值 </li>
<li>理解执行环境 </li>
<li>理解垃圾收集</li>
</ul>
<h2 id="4-1-基本类型和引用类型的值"><a href="#4-1-基本类型和引用类型的值" class="headerlink" title="4.1 基本类型和引用类型的值"></a>4.1 基本类型和引用类型的值</h2><p>ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。<br><strong>基本数据类型</strong>：Undefined、Null、Boolean、Number 和 String。这 5 种基本数据类型是<strong>按值访问</strong>的，因为可以操作保存在变量中的实际的值。<br>引用类型的值是<strong>保存在内存中的对象</strong>。与其他语言不同，JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。引用类型的值是按引用访问的（但在为对象添加属性时，操作的是实际的对象）。</p>
<blockquote>
<p>在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。ECMAScript 放弃了这一传统。</p>
</blockquote>
<h3 id="4-1-1-动态的属性"><a href="#4-1-1-动态的属性" class="headerlink" title="4.1.1 动态的属性"></a>4.1.1 动态的属性</h3><p>对于引用类型的值，我们可以为其<strong>添加属性和方法</strong>，也可以改变和删除其属性和方法。但基本数据类型不行。</p>
<h3 id="4-1-2-复制变量值"><a href="#4-1-2-复制变量值" class="headerlink" title="4.1.2 复制变量值"></a>4.1.2 复制变量值</h3><p>对于基本数据类型，如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值。<br>对于引用类型，复制引用类型的值时，这个值的副本实际上<strong>是一个指针</strong>。</p>
<h3 id="4-1-3-传递参数"><a href="#4-1-3-传递参数" class="headerlink" title="4.1.3 传递参数"></a>4.1.3 传递参数</h3><p>ECMAScript 中所有函数的参数都是<strong>按值传递</strong>的。对于基本数据类型和引用类型，分别按照4.1.2的规则来（这在很多编程语言上有所体现）。<br>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数arguments对象里的一个元素）。<br>在向参数传递引用类型的值时，会把这个值在内存中的地址<strong>复制</strong>给一个局部变量（因此不是按引用传递，而是按值传递）。<br>看这个例子来说明是按值传递的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123; </span><br><span class="line">    obj.name = <span class="string">"Nicholas"</span>; </span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//函数执行完之后这个obj还会被立即销毁</span></span><br><span class="line">    obj.name = <span class="string">"Greg"</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">setName(person); </span><br><span class="line">alert(person.name);    <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>
<h3 id="4-1-4-检测类型"><a href="#4-1-4-检测类型" class="headerlink" title="4.1.4 检测类型"></a>4.1.4 检测类型</h3><p><strong>typeof 操作符</strong>是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具。<br>检测是什么类型的对象使用<strong>instanceof 操作符</strong>。其语法如下所示： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">result = variable <span class="keyword">instanceof</span> <span class="keyword">constructor</span></span><br></pre></td></tr></table></figure>
<p>补充一下：用variable.__proto__也是能查看的。</p>
<h2 id="4-2-执行环境及作用域"><a href="#4-2-执行环境及作用域" class="headerlink" title="4.2 执行环境及作用域"></a>4.2 执行环境及作用域</h2><p><strong>执行环境</strong>（execution context）定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的<strong>变量对象</strong>（variable object），环境中定义的所有变量和函数都保存在这个对象中。<br>全局执行环境是最外围的一个执行环境。在 Web 浏览器中，全局执行环境被认为是 window 对象（第 7 章将详细讨论），因此所有全局变量和函数都是作为 window 对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。<br>每个函数都有自己的<strong>执行环境</strong>。当执行流进入一个函数时，函数的环境就会被推入一个<strong>环境栈</strong>中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。<br>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的变量对象由内逐渐延续到全局执行环境，全局执行环境的变量对象始终都是作用域链中的最后一个对象。<br>举例说明（很多编程语言都有这个概念，即从局部变量、全局变量来理解）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> anotherColor = <span class="string">"red"</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">var</span> tempColor = anotherColor; </span><br><span class="line">        anotherColor = color; </span><br><span class="line">        color = tempColor; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 这里可以访问 color、anotherColor 和 tempColor </span></span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 这里可以访问 color 和 anotherColor，但不能访问 tempColor </span></span><br><span class="line">    swapColors(); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这里只能访问 color </span></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>

<h3 id="4-2-1-延长作用域链"><a href="#4-2-1-延长作用域链" class="headerlink" title="4.2.1 延长作用域链"></a>4.2.1 延长作用域链</h3><p>有些语句可以<strong>在作用域链的前端临时增加一个变量对象</strong>，该变量对象会在代码执行后被移除。当执行流进入下列任何一个语句时，作用域链就会得到加长：</p>
<ul>
<li>try-catch 语句的 catch 块； </li>
<li>with 语句。<br>对 with 语句来说，会将指定的对象添加到作用域链中。对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。<br>看个例子：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> qs = <span class="string">"?debug=true"</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">with</span>(location)&#123; </span><br><span class="line">        <span class="keyword">var</span> url = href + qs;         </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> url; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其实就相当于（with的写法仅仅为了方便而已）：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> qs = <span class="string">"?debug=true"</span>;    </span><br><span class="line">    <span class="keyword">var</span> url = location.href + qs;       </span><br><span class="line">    <span class="keyword">return</span> url; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-2-2-没有块级作用域"><a href="#4-2-2-没有块级作用域" class="headerlink" title="4.2.2 没有块级作用域"></a>4.2.2 没有块级作用域</h3><p>看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">    <span class="keyword">var</span> color = <span class="string">"blue"</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">alert(color);    <span class="comment">//"blue"</span></span><br></pre></td></tr></table></figure>
<p>在其它语言中，color 会在 if 语句执行完毕后被销毁。但在 JS 中，<strong>if 语句</strong>中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。在使用 <strong>for 语句</strong>时尤其要牢记这一差异（函数内不会，因为函数有自己的局部环境）（这将在ES6使用let从而改善）。</p>
<ul>
<li><p>声明变量<br>使用 var 声明的变量会自动被添加到最接近的环境中。如果初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123; </span><br><span class="line">    sum = num1 + num2; </span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">10</span>, <span class="number">20</span>);  <span class="comment">//30 </span></span><br><span class="line">alert(sum); <span class="comment">//30</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>一定记得要声明</strong>。不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。</p>
</blockquote>
</li>
<li><p>查询标识符<br>当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。</p>
</li>
</ul>
<div  align="center">    
<img src="/images/search_path.png" width = 380 height = 380 />
</div>



<h2 id="4-3-垃圾收集"><a href="#4-3-垃圾收集" class="headerlink" title="4.3 垃圾收集"></a>4.3 垃圾收集</h2><p>垃圾收集机制的<strong>原理</strong>其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。垃圾收集器会<strong>按照固定的时间间隔</strong>（或代码执行中预定的收集时间），周期性地执行这一操作。<br>用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。 </p>
<h3 id="4-3-1-标记清除"><a href="#4-3-1-标记清除" class="headerlink" title="4.3.1 标记清除"></a>4.3.1 标记清除</h3><p>JavaScript 中最常用的垃圾收集方式是<strong>标记清除</strong>（mark-and-sweep）。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。而当变量离开环境时，则将其标记为“离开环境”。<br>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。<br>可以使用任何方式来标记变量，如何标记变量其实并不重要，关键在于采取什么策略。 </p>
<h3 id="4-3-2-引用计数"><a href="#4-3-2-引用计数" class="headerlink" title="4.3.2 引用计数"></a>4.3.2 引用计数</h3><p>另一种不太常见的垃圾收集策略叫做<strong>引用计数</strong>（reference counting）。引用计数的含义是跟踪记录每个值被引用的次数。一个严重的问题：<strong>循环引用</strong>。循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用。<br>看例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> objectA = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">    <span class="keyword">var</span> objectB = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line"> </span><br><span class="line">    objectA.someOtherObject = objectB; </span><br><span class="line">    objectB.anotherObject = objectA; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数执行完毕后，objectA 和 objectB 还将继续存在，因为它们的引用次数永远不会是 0。<br>所以现在应该都是用“标记清除”的策略了吧。</p>
<h3 id="4-3-3-性能问题"><a href="#4-3-3-性能问题" class="headerlink" title="4.3.3 性能问题"></a>4.3.3 性能问题</h3><p>垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，<strong>确定垃圾收集的时间间隔</strong>是一个非常重要的问题。此前IE的垃圾收集器根据内存分配量来运行的，达到某个临界值垃圾收集器就会运行，若是某个脚本在其生命周期中一直保有那么多的变量，垃圾收集器就会频繁运行造成严重性能问题。后来临界值被调整为动态修正，改善了性能。</p>
<h3 id="4-3-4-管理内存"><a href="#4-3-4-管理内存" class="headerlink" title="4.3.4 管理内存"></a>4.3.4 管理内存</h3><p>一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做<strong>解除引用</strong>（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。<br>不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。 </p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 - 基本概念</title>
    <url>/2020/03/20/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB-JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-20-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>本章内容 </p>
<ul>
<li>语法 </li>
<li>数据类型 </li>
<li>流控制语句 </li>
<li>函数 </li>
</ul>
<p>摘选一些基本概念以供之后参考。</p>
<h2 id="3-4数据类型"><a href="#3-4数据类型" class="headerlink" title="3.4数据类型"></a>3.4数据类型</h2><h3 id="3-4-1-typeof操作符"><a href="#3-4-1-typeof操作符" class="headerlink" title="3.4.1 typeof操作符"></a>3.4.1 typeof操作符</h3><p>typeof 操作符的操作数可以是变量（message），也可以是数值字面量。<strong>typeof 是一个操作符</strong>而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的。</p>
<h3 id="3-4-2-Undefined类型"><a href="#3-4-2-Undefined类型" class="headerlink" title="3.4.2 Undefined类型"></a>3.4.2 Undefined类型</h3><p>Undefined 类型只有一个值，即特殊的 undefined。在使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined。</p>
<h3 id="3-4-3-Null类型"><a href="#3-4-3-Null类型" class="headerlink" title="3.4.3 Null类型"></a>3.4.3 Null类型</h3><p>从逻辑角度来看，<strong>null 值表示一个空对象指针</strong>，而这也正是使用 typeof 操作符检测 null 值时会返回”object”的原因。<br>如果定义的变量准备在将来用于保存对象，那么<strong>最好将该变量初始化为 null</strong>而不是其他值。<br>下表给出了各种数据类型及其对应的转换规则。 </p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="center">转换为true值</th>
<th align="right">转换为false值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Boolean</td>
<td align="center">truw</td>
<td align="right">false</td>
</tr>
<tr>
<td align="left">String</td>
<td align="center">非空字符串</td>
<td align="right">‘’(空字符串)</td>
</tr>
<tr>
<td align="left">Number</td>
<td align="center">非零数字</td>
<td align="right">0和NaN</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="center">任何对象</td>
<td align="right">null</td>
</tr>
<tr>
<td align="left">undefined</td>
<td align="center">N/A</td>
<td align="right">undefined</td>
</tr>
</tbody></table>
<h3 id="3-4-5-Number类型"><a href="#3-4-5-Number类型" class="headerlink" title="3.4.5 Number类型"></a>3.4.5 Number类型</h3><ul>
<li><p>浮点数值<br>由于保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript 会<strong>不失时机地将浮点数值转换为整数值</strong>。如果浮点数值本身表示的就是一个整数（如 1.0），那么该值也会被转换为整数。<br>可以<strong>用 e 表示法（即科学计数法）</strong>表示的浮点数值表示。</p>
</li>
<li><p>数值范围<br>ECMAScript 能够表示的最小数值保存在 <strong>Number.MIN_VALUE</strong> 中——在大多数浏览器中，这个值是 5e-324；能够表示的最大数值保存在<strong>Number.MAX_VALUE</strong> 中——在大多数浏览器中，这个值是 1.7976931348623157e+308。超过的数值会被转化为-Infinity（负无穷），Infinity（正无穷）。</p>
</li>
<li><p>NaN<br>这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。<br>两个特点：首先，任何涉及 NaN 的操作（例如 NaN/10）都会返回 NaN；其次，NaN 与任何值都不相等，包括 NaN 本身。<br>针对 NaN 的这两个特点，ECMAScript 定义了 isNaN()函数：这个函数接受一个参数，该参数可以是任何类型，而函数会<strong>帮我们确定这个参数是否“不是数值”</strong>。任何不能被转换为数值的值都会导致这个函数返回 true（比如NaN, 字母字符串）。</p>
</li>
<li><p>数值转换<br>有 3 个函数可以把非数值转换为数值：Number()、parseInt()和 parseFloat()。 <strong>Number()可以用于任何数据类型</strong>，而<strong>另两个函数则专门用于把字符串转换成数值</strong>。<br>Number()函数的转换规则如下。 </p>
<ul>
<li>如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。 </li>
<li>如果是数字值，只是简单的传入和返回。 </li>
<li>如果是 null 值，返回 0。 </li>
<li>如果是 undefined，返回 NaN。</li>
<li>如果是字符串, 有“数字”的能转则转（规则繁杂）。 </li>
</ul>
</li>
</ul>
<p><strong>在处理整数的时候更常用的是parseInt()函数。</strong>parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回 NaN；<br>规则举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"1234blue"</span>);    <span class="comment">// 1234 </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">""</span>);            <span class="comment">// NaN </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">"0xA"</span>);         <span class="comment">// 10（十六进制数） </span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>);          <span class="comment">// 22 </span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseInt</span>(<span class="string">"070"</span>);         <span class="comment">// 56（存在分歧，八进制数） </span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseInt</span>(<span class="string">"70"</span>);         <span class="comment">// 70（十进制数） </span></span><br><span class="line"><span class="keyword">var</span> num7 = <span class="built_in">parseInt</span>(<span class="string">"0xf"</span>);         <span class="comment">// 15（十六进制数）</span></span><br></pre></td></tr></table></figure>
<p>与 parseInt()函数类似，parseFloat()也是从第一个字符（位置 0）开始解析每个字符。除了<strong>第一个小数点有效</strong>之外，parseFloat()与 parseInt()的第二个区别在于它<strong>始终都会忽略前导的零</strong>。几个典型示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">"1234blue"</span>); <span class="comment">//1234 （整数） </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">"0xA"</span>); <span class="comment">//0 </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">"22.5"</span>); <span class="comment">//22.5 </span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">"22.34.5"</span>); <span class="comment">//22.34 </span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">"0908.5"</span>); <span class="comment">//908.5 </span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">"3.125e7"</span>); <span class="comment">//31250000</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-6-String类型"><a href="#3-4-6-String类型" class="headerlink" title="3.4.6 String类型"></a>3.4.6 String类型</h3><ul>
<li>字符字面量<br>\n 换行, \t 制表, \b 空格, \r 回车, \f 进纸, \ 斜杠 ;<br>\xnn 以十六进制代码nn表示的一个字符（其中n为0～F）。例如，\x41表示”A” ;<br>\unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0～F）。例如，\u03a3表示希腊字符Σ 。</li>
<li>字符串特点<br>字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。</li>
<li>转换为字符串<br>两种方式。第一种是使用几乎每个值都有的 toString()方法（继承自object）：默认情况下，toString()方法以十进制格式返回数值的字符串表示。而通过传递基数，<strong>toString()可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式</strong>表示的字符串值。<br>还可以使用转型函数 String()，String()函数遵循下列转换规则： </li>
<li>如果值有 toString()方法，则调用该方法（没有参数）并返回相应的结果； </li>
<li>如果值是 null，则返回”null”； </li>
<li>如果值是 undefined，则返回”undefined”。</li>
</ul>
<h3 id="3-4-7-Object类型"><a href="#3-4-7-Object类型" class="headerlink" title="3.4.7 Object类型"></a>3.4.7 Object类型</h3><p>Object 的每个实例都具有下列属性和方法：</p>
<ul>
<li>constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是 Object()。 </li>
<li>hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例<br>如：o.hasOwnProperty(“name”)）。 </li>
<li>isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型（第 5 章将讨论原型）。 </li>
<li>propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in 语句（本章后面将会讨论）来枚举。与 hasOwnProperty()方法一样，作为参数的属性名必须以字符<br>串形式指定。 </li>
<li>toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。 </li>
<li>toString()：返回对象的字符串表示。 </li>
<li>valueOf()：返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值相同</li>
</ul>
<h2 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5 操作符"></a>3.5 操作符</h2><h3 id="3-5-1-一元操作符"><a href="#3-5-1-一元操作符" class="headerlink" title="3.5.1 一元操作符"></a>3.5.1 一元操作符</h3><h3 id="3-5-2-位操作符"><a href="#3-5-2-位操作符" class="headerlink" title="3.5.2 位操作符"></a>3.5.2 位操作符</h3><p>位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript 中的所有数值都以 IEEE-754 64 位格式存储，但<strong>位操作符并不直接操作 64 位的值</strong>。而是先将 64 位的值转换成 32 位的整数，然后执行操作，最后再将结果转换回 64 位。<br>对于有符号的整数，32 位中的前 31 位用于表示整数的值。第 32 位用于表示数值的符号：0 表示正数，1 表示负数。这个表示符号的位叫做<strong>符号位</strong>，符号位的值决定了其他位数值的格式。<br>负数同样<strong>以二进制码存储</strong>，但使用的格式是二进制补码。<br><strong>计算一个数值的二进制补码三步骤</strong>：<br>(1) 求这个数值绝对值的二进制码（例如，要求18 的二进制补码，先求 18 的二进制码）；<br>(2) 求二进制反码，即将 0 替换为 1，将 1 替换为 0；<br>(3) 得到的二进制反码加 1。<br>如-18 的二进制表示，即11111111111111111111111111101110。这里不展示举例过程。不过ECMAScript 会尽力向我们隐藏所有这些信息，我们看到的只是这个负数绝对值的二进制码前面加上了一个负号。。</p>
<ul>
<li>按位非（NOT）<br>按位非操作符由一个波浪线（~）表示。二进制上取反，表现出来就是按位非操作的本质：操作数的负值减 1。如num1 = 25, num2 = ~nums1 == -26。</li>
<li>按位与（AND）<br>按位与操作符由一个和号字符（&amp;）表示，它有两个操作符数。按位与操作只在两个数值的对应位都是 1 时才返回 1，任何一位是 0，结果都是 0。 </li>
<li>按位或（OR）<br>按位或操作符由一个竖线符号（|）表示，同样也有两个操作数。按位或操作在有一个位是 1 的情况下就返回 1，而只有在两个位都是 0 的情况下才返回 0。</li>
<li>按位异或（XOR）<br>按位异或操作符由一个插入符号（^）表示，也有两个操作数。操作在两个数值对应位上只有一个 1 时才返回 1，如果对应的两位都是 1 或都是 0，则返回 0。 </li>
<li>左移<br>左移操作符由两个小于号（&lt;&lt;）表示，这个操作符会将数值的所有位向左移动指定的位数。左移操作会以 0 来填充这些空位，以便得到的结果是一个完整的 32 位二进制数。注意，左移不会影响操作数的符号位。</li>
<li>有符号的右移<br>有符号的右移操作符由两个大于号（&gt;&gt;）表示，这个操作符会将数值向右移动，但保留符号位（即正负号标记）。<br>在移位过程中，原数值中也会出现空位，此时 ECMAScript 会<strong>用符号位的值来填充所有空位</strong>，以便得到一个完整的值。</li>
<li>无符号右移<br>无符号右移操作符由 3 个大于号（&gt;&gt;&gt;）表示，这个操作符会将数值的所有 32 位都向右移动。<br>对正数来说，无符号右移的结果与有符号右移相同。但对负数的结果就不一样了。由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果<strong>非常之大</strong>。<br>var oldValue = -64; // 等于二进制的 11111111111111111111111111000000<br>var newValue = oldValue &gt;&gt;&gt; 5; // 等于十进制的 134217726 <h3 id="3-5-3-布尔操作符"><a href="#3-5-3-布尔操作符" class="headerlink" title="3.5.3 布尔操作符"></a>3.5.3 布尔操作符</h3></li>
<li>逻辑非<br>逻辑非操作符遵循下列规则：<ul>
<li>如果操作数是任意非 0 数值（包括 Infinity），返回 false； </li>
<li>如果操作数是 null，返回 true； </li>
<li>如果操作数是 NaN，返回 true； </li>
<li>如果操作数是 undefined，返回 true。<br>同时使用两个逻辑非操作符，实际上就会模拟 Boolean()函数的行为。</li>
</ul>
</li>
<li>逻辑与 </li>
<li>逻辑或</li>
</ul>
<h3 id="3-5-4-乘性操作符"><a href="#3-5-4-乘性操作符" class="headerlink" title="3.5.4 乘性操作符"></a>3.5.4 乘性操作符</h3><p>乘法*，除法/，求模%。<br>在操作数为非数值的情况下<strong>会执行自动的类型转换</strong>，后台会先使用 Number()转型函数将其转换为数值。</p>
<h3 id="3-5-6-关系操作符"><a href="#3-5-6-关系操作符" class="headerlink" title="3.5.6 关系操作符"></a>3.5.6 关系操作符</h3><p>小于（&lt;）、大于（&gt;）、小于等于（&lt;=）和大于等于（&gt;=）这几个关系操作符。<br>当关系操作符的操作数使用了非数值时，所遵循的规则：</p>
<ul>
<li>如果两个操作数都是数值，则执行数值比较。 </li>
<li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。 </li>
<li>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。 </li>
<li>如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面的规则执行比较。 </li>
<li>如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。</li>
</ul>
<h3 id="3-5-7-相等操作符"><a href="#3-5-7-相等操作符" class="headerlink" title="3.5.7 相等操作符"></a>3.5.7 相等操作符</h3><p>最早的 ECMAScript 中的相等和不等操作符会在执行比较之前，先将对象转换成相似的类型。最后，ECMAScript 的解决方案就是提供两组操作符：<strong>相等和不相等</strong>——先转换再比较，<strong>全等和不全等</strong>——仅比较而不转换。</p>
<ul>
<li><p>相等和不相等（<strong>先转换后比较</strong>）<br>相等操作符由（==）表示，如果两个操作数相等，则返回 true。不相等操作符由（!=）表示，如果两个操作数不相等，则返回 true。</p>
</li>
<li><p>全等和不全等（<strong>不转换仅比较</strong>）<br>全等操作符由 3 个等于号（===）表示。不全等操作符由一个叹号后跟两个等于号（!==）表示。</p>
</li>
</ul>
<h2 id="3-6-语句"><a href="#3-6-语句" class="headerlink" title="3.6 语句"></a>3.6 语句</h2><h3 id="3-6-6-label语句"><a href="#3-6-6-label语句" class="headerlink" title="3.6.6 label语句"></a>3.6.6 label语句</h3><p>使用 label 语句可以在代码中添加标签，可以在将来由 break 或 continue 语句引用。在函数前加label：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">outermost: </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123; </span><br><span class="line">            <span class="keyword">continue</span> outermost; </span><br><span class="line">        &#125; </span><br><span class="line">        num++; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-8-with语句"><a href="#3-6-8-with语句" class="headerlink" title="3.6.8 with语句"></a>3.6.8 with语句</h3><p>with 语句的作用是将代码的作用域设置到一个特定的对象中。with 语句的语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> (expression) statement;</span><br></pre></td></tr></table></figure>
<p>定义 with 语句的目的主要是为了简化多次编写同一个对象的工作，如下面的例子所示： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = location.search.substring(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">var</span> hostName = location.hostname; </span><br><span class="line"><span class="keyword">var</span> url = location.href;</span><br></pre></td></tr></table></figure>
<p>上面几行代码都包含 location 对象。如果使用 with 语句，可以把上面的代码改写成如下所示： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span>(location)&#123; </span><br><span class="line">    <span class="keyword">var</span> qs = search.substring(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">var</span> hostName = hostname; </span><br><span class="line">    <span class="keyword">var</span> url = href; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用 with 语句。</p>
</blockquote>
<h3 id="3-7-1-理解参数"><a href="#3-7-1-理解参数" class="headerlink" title="3.7.1 理解参数"></a>3.7.1 理解参数</h3><p>ECMAScript 函数<strong>不介意传递进来多少个参数</strong>，也不在乎传进来参数是什么数据类型。原因是 ECMAScript 中的<strong>参数在内部是用一个数组来表示的</strong>。实际上，在函数体内可以通过 <strong>arguments 对象</strong>来访问这个参数数组，从而获取传递给函数的每一个参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">num1, num2</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">1</span>) &#123; </span><br><span class="line">       alert(num1 + <span class="number">10</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">2</span>) &#123; </span><br><span class="line">        alert(<span class="built_in">arguments</span>[<span class="number">0</span>] + num2); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 arguments 的行为，还有一点比较有意思。那就是它的值永远与对应命名参数的值保持同步。<br>关于参数还要记住最后一点：没有传递值的命名参数将自动被赋予 undefined 值。</p>
<h3 id="3-7-2-没有重载"><a href="#3-7-2-没有重载" class="headerlink" title="3.7.2 没有重载"></a>3.7.2 没有重载</h3><p>在其他语言（如 Java）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。<br>JS没有函数签名，真正的重载是不可能做到的。 如前所述，通过检查传入函数中参数的类型和数量并作出不同的反应，<strong>可以模仿方法的重载</strong>。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 - 在HTML中使用JS</title>
    <url>/2020/03/20/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB-JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-20-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8JS/</url>
    <content><![CDATA[<p>本章内容 </p>
<ul>
<li>使用\script元素 </li>
<li>嵌入脚本与外部脚本 </li>
<li>文档模式对 JavaScript 的影响 </li>
<li>考虑禁用 JavaScript 的场景</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>把 JavaScript 插入到 HTML 页面中要使用script元素。使用这个元素可以把 JavaScript 嵌入到HTML 页面中，让脚本与标记混合在一起；也可以包含外部的 JavaScript 文件。而我们需要注意的地方有：</p>
<ul>
<li>在包含外部 JavaScript 文件时，必须将 src 属性设置为指向相应文件的 URL。而这个文件既可以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。 </li>
<li>所有script元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用 defer 和async 属性的情况下，只有在解析完前面script元素中的代码之后，才会开始解析后面script元素中的代码。 </li>
<li>由于浏览器会先解析完不使用 defer 属性的script元素中的代码，然后再解析后面的内容，所以一般应该把script元素放在页面最后，即主要内容后面，&lt;/body&gt;标签前面。 </li>
<li>使用 defer属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。</li>
<li>使用 async 属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。<br>另外，使用&lt;noscript&gt;元素可以指定在不支持脚本的浏览器中显示的替代内容。但在启用了脚本的情况下，浏览器不会显示&lt;noscript&gt;元素中的任何内容。 </li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章 - JS简介</title>
    <url>/2020/03/20/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB-JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-20-%E7%AC%AC%E4%B8%80%E7%AB%A0-JS%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>本章内容 </p>
<ul>
<li>JavaScript 历史回顾 </li>
<li>JavaScript 是什么 </li>
<li>JavaScript 与 ECMAScript 的关系 </li>
</ul>
<p>JS诞生于1995年，诞生的主要目的是为了处理一些输入验证操作，而在JS出现以前这些操作是由后端来完成的，可以说解决了一个痛点。<br>现在JS有了更多的功能。</p>
<h2 id="1-1-JS的简史"><a href="#1-1-JS的简史" class="headerlink" title="1.1 JS的简史"></a>1.1 JS的简史</h2><p>JS由Netscape 公司所开发，为了就是处理简单的验证。由于JS1.0获得了巨大成功，然后微软也进来插一脚，在IE3加入了JScript。到了1997年，为了使市面上的两种JS有个规范，共同制定了ECMA，即ECMAScript。</p>
<h2 id="1-2-JS的实现"><a href="#1-2-JS的实现" class="headerlink" title="1.2 JS的实现"></a>1.2 JS的实现</h2><p>一个完整的 JavaScript 实现应该由下列三个不同的部分组成:</p>
<ul>
<li>核心（ECMAScript） </li>
<li>文档对象模型（DOM） </li>
<li>浏览器对象模型（BOM）</li>
</ul>
<h3 id="1-2-1-ECMAScript"><a href="#1-2-1-ECMAScript" class="headerlink" title="1.2.1 ECMAScript"></a>1.2.1 ECMAScript</h3><p><strong>提供核心语言功能</strong>。常见的 Web 浏览器只是 ECMAScript 实现可能的宿主环境之一，其他宿主环境包括 Node（一种服务端 JavaScript 平台）和 Adobe Flash。</p>
<h3 id="1-2-2-文档对象模型（DOM）"><a href="#1-2-2-文档对象模型（DOM）" class="headerlink" title="1.2.2 文档对象模型（DOM）"></a>1.2.2 文档对象模型（DOM）</h3><p><strong>提供访问和操作网页内容的方法和接口</strong>。文档对象模型（DOM，Document Object Model）是针对 XML 但经过扩展用于 HTML 的应用程序编程接口（API，Application Programming Interface）。借助DOM 提供的 API，开发人员可以轻松自如地删除、添加、替换或修改任何节点。</p>
<h3 id="1-2-3-浏览器对象模型（BOM）"><a href="#1-2-3-浏览器对象模型（BOM）" class="headerlink" title="1.2.3 浏览器对象模型（BOM）"></a>1.2.3 浏览器对象模型（BOM）</h3><p><strong>提供与浏览器交互的方法和接口</strong>。开发人员使用 BOM 可以控制浏览器显示的页面以外的部分。<br>人们习惯上把所有针对浏览器的 JavaScript 扩展算作 BOM 的一部分。下面就是一些这样的扩展：</p>
<ul>
<li>弹出新浏览器窗口的功能； </li>
<li>移动、缩放和关闭浏览器窗口的功能； </li>
<li>提供浏览器详细信息的 navigator 对象； </li>
<li>提供浏览器所加载页面的详细信息的 location 对象； </li>
<li>提供用户显示器分辨率详细信息的 screen 对象； </li>
<li>对 cookies 的支持； </li>
<li>像 XMLHttpRequest 和 IE 的 ActiveXObject 这样的自定义对象</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉堆实现优先级队列</title>
    <url>/2020/03/20/%E7%AE%97%E6%B3%95-3-20-Al-BinaryHeap/</url>
    <content><![CDATA[<p>二叉堆（Binary Heap）其主要操作就两个，sink（下沉）和 swim（上浮），用以维护二叉堆的性质。其主要应用有两个，首先是一种排序方法「堆排序」，第二是一种很有用的数据结构「优先级队列」。</p>
<a id="more"></a>


<h2 id="一、二叉堆概览"><a href="#一、二叉堆概览" class="headerlink" title="一、二叉堆概览"></a>一、二叉堆概览</h2><p>二叉堆其实就是一种特殊的二叉树（完全二叉树），只不过存储在数组里。在数组里，我们把数组索引作为指针：<br>二叉堆还分为最大堆和最小堆。最大堆的性质是：每个节点都大于等于它的两个子节点。类似的，最小堆的性质是：每个节点都小于等于它的子节点。</p>
<div  align="center">    
<img src="/images/binaryHeap.png" width = 400 height = 300 />
</div>


<h2 id="二、优先级队列实现"><a href="#二、优先级队列实现" class="headerlink" title="二、优先级队列实现"></a>二、优先级队列实现</h2><p>数据结构的功能无非增删查该，优先级队列有两个主要 API，分别是 insert 插入一个元素和 delMax 删除最大元素（如果底层用最小堆，那么就是 delMin）。<br>以下是代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxPriorityQueue</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    优先级队列, 最大堆</span></span><br><span class="line"><span class="string">    方法: 返回最大值maxNum, 插入操作insert, 删除最大元素delMax</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pq = []</span><br><span class="line">        self.N = <span class="number">0</span></span><br><span class="line">        self.pq.append(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNum</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''方法：返回最大值'''</span></span><br><span class="line">        <span class="keyword">return</span> self.pq[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, e)</span>:</span></span><br><span class="line">        <span class="string">'''方法：插入操作'''</span></span><br><span class="line">        self.N += <span class="number">1</span></span><br><span class="line">        self.pq.append(e)</span><br><span class="line">        self.__swim(self.N)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delMax</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''方法：删除最大元素并返回'''</span></span><br><span class="line">        themax = self.pq[<span class="number">1</span>]</span><br><span class="line">        self.__exchange(<span class="number">1</span>, self.N)</span><br><span class="line">        self.pq[self.N] = <span class="literal">None</span></span><br><span class="line">        self.N -= <span class="number">1</span></span><br><span class="line">        self.__sink(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> themax</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__parent</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">'''私有：返回父节点的秩'''</span></span><br><span class="line">        <span class="keyword">return</span> root // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__left</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">'''私有：返回左节点的秩'''</span></span><br><span class="line">        <span class="keyword">return</span> root * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__right</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">'''私有：返回右节点的秩'''</span></span><br><span class="line">        <span class="keyword">return</span> root * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exchange</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="string">'''私有：交换'''</span></span><br><span class="line">        self.pq[i], self.pq[j] = self.pq[j], self.pq[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__less</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="string">'''私有：比较'''</span></span><br><span class="line">        <span class="keyword">return</span> self.pq[i] &lt; self.pq[j]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__swim</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">'''私有：上浮'''</span></span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">1</span> <span class="keyword">and</span> self.__less(self.__parent(k), k):</span><br><span class="line">            self.__exchange(self.__parent(k), k)</span><br><span class="line">            k = self.__parent(k)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__sink</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="string">'''私有：下沉'''</span></span><br><span class="line">        <span class="keyword">while</span> self.__left(k) &lt;= self.self.N:</span><br><span class="line">            older = self.__left(k)</span><br><span class="line">            <span class="keyword">if</span> self.__right(k) &lt;= self.N <span class="keyword">and</span> self.__less(older, self.__right(k)):</span><br><span class="line">                older = self.__right(k)</span><br><span class="line">            <span class="keyword">if</span> older &lt; k:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            self.__exchange(k, older)</span><br><span class="line">            k = older</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">a = MaxPriorityQueue()</span><br><span class="line">lists = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">33</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">355</span>, <span class="number">7</span>, <span class="number">72</span>, <span class="number">145</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> lists:</span><br><span class="line">    a.insert(x)</span><br><span class="line">print(a.maxNum())</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建参考总结</title>
    <url>/2020/03/20/%E5%85%B6%E5%AE%83-3-20-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>虽然搭建这个博客很简单, 但还是记录一下;)</p>
<a id="more"></a>

<p>以下是我的搭建历程:</p>
<ul>
<li>搭建这个博客主要是: hexo + githubPage, 很简单, 网上的教程很多, 这里不再赘述.</li>
<li>主题是<a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">Maupassant</a>, 这篇博文有详细的配置说明, 如何安装hexo主题, 百度一下.</li>
<li>安装插件: 评论插件\统计插件等等</li>
<li>这篇博文介绍很详细, 可以跟着做, 各种插件的介绍:<a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">最全Hexo博客搭建</a></li>
<li>了解hexo的基本操作:<a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">Hexo官方文档</a></li>
<li>可选:购买域名, 不过感觉加了域名访问变慢了一丢丢…</li>
<li>最后为了实现提交git而能自动生成页面, 使用了Travis-ci, 花了好长时间, 不嫌麻烦也可以百度一下教程.<a href="https://travis-ci.org/" target="_blank" rel="noopener">travis-ci</a></li>
</ul>
<p>常用的hexo命令:</p>
<ul>
<li>清除：hexo clean</li>
<li>生成并发布：hexo g -d</li>
<li>gulp压缩：gulp</li>
<li>新建新博文：hexo new title</li>
</ul>
]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
